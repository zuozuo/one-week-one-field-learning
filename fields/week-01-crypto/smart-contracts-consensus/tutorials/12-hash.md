# 哈希函数（Hash Function）

## 一句话大白话

**哈希函数就是给任何数据生成"数字指纹"**：不管你输入多大的文件，输出都是固定长度的一串数字。改动输入的任何一个字符，输出都会面目全非。

---

## 它解决什么问题

### 核心需求：快速验证数据完整性

```
场景：你下载了一个 10GB 的文件，怎么确认没有被篡改？

传统方法：
- 保留原始文件的完整副本
- 逐字节比对
- 代价：10GB 存储 + 10GB 比对

哈希方法：
- 只保留 256 位的哈希值（32 字节）
- 下载后重新计算哈希
- 比对 32 字节
- 代价：32 字节存储 + 一次哈希计算
```

### 哈希在区块链中的应用

```
┌─────────────────────────────────────────────────────────────────┐
│                  哈希在区块链中的角色                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 区块链接                                                    │
│     每个区块包含前一个区块的哈希 → 链式结构                     │
│                                                                 │
│  2. 交易 ID                                                     │
│     交易的哈希值就是交易 ID                                      │
│                                                                 │
│  3. Merkle 树                                                   │
│     交易哈希层层聚合，形成根哈希                                 │
│                                                                 │
│  4. 地址生成                                                    │
│     公钥 → 哈希 → 地址                                          │
│                                                                 │
│  5. PoW 挖矿                                                    │
│     寻找满足条件的哈希值                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 什么时候用 / 什么时候别用

### ✅ 适合用哈希的场景

| 场景 | 原因 |
|------|------|
| 数据完整性验证 | 快速检测篡改 |
| 密码存储 | 不存明文，只存哈希 |
| 数字签名 | 先哈希再签名，效率高 |
| 去重 | 相同内容哈希相同 |
| 数据索引 | 固定长度，便于检索 |

### ❌ 不适合用哈希的场景

| 场景 | 原因 |
|------|------|
| 数据加密 | 哈希不可逆，无法解密 |
| 压缩数据 | 哈希值不能还原原数据 |
| 相似性检测 | 微小改动导致完全不同的输出 |

---

## 它不是什么（常见混淆点）

### ❌ 哈希 ≠ 加密

```
加密：可以解密，恢复原文
哈希：不可逆，无法恢复

加密：保护数据不被看到
哈希：验证数据没有被改

┌─────────────────┐      ┌─────────────────┐
│     加密        │      │     哈希        │
├─────────────────┤      ├─────────────────┤
│ 明文 + 密钥     │      │ 任意输入        │
│       ↓         │      │       ↓         │
│     密文        │      │   固定长度输出   │
│       ↓         │      │       ✗         │
│ 密文 + 密钥     │      │   无法还原       │
│       ↓         │      │                 │
│     明文 ✓      │      │                 │
└─────────────────┘      └─────────────────┘
```

### ❌ 哈希碰撞 ≠ 破解哈希

```
碰撞：找到两个不同的输入，产生相同的哈希
破解：给定一个哈希，找到对应的输入

碰撞是理论上存在的（因为输入无限，输出有限）
但对于好的哈希函数，两者都极难实现

SHA-256 碰撞：
- 需要尝试约 2^128 次
- 这个数字大于宇宙中原子的数量
```

### ❌ MD5/SHA-1 ≠ 安全

```
❌ 不要使用：
- MD5：已被破解，几秒内可找到碰撞
- SHA-1：也已不安全

✅ 推荐使用：
- SHA-256：比特币、以太坊使用
- SHA-3 (Keccak)：以太坊的 keccak256
- BLAKE2/BLAKE3：更快，同样安全
```

---

## 最小例子

### 哈希的基本性质

```
┌─────────────────────────────────────────────────────────────────┐
│                    哈希函数的 5 个核心性质                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 确定性                                                      │
│     相同输入 → 相同输出（永远）                                  │
│                                                                 │
│  2. 快速计算                                                    │
│     任意大小的输入都能快速得到结果                               │
│                                                                 │
│  3. 雪崩效应                                                    │
│     输入改变 1 bit → 输出改变约 50% 的 bits                     │
│                                                                 │
│  4. 单向性（抗原像）                                            │
│     给定哈希值，无法反推出输入                                   │
│                                                                 │
│  5. 抗碰撞性                                                    │
│     极难找到两个不同输入产生相同输出                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 雪崩效应示例

```
输入 1: "hello"
SHA-256: 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824

输入 2: "hellp" (只改了一个字母)
SHA-256: 7a9d63e7e4e9d5b0c9e4f5e0c1b2a3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0

完全不同！无法看出任何关联。
```

### 代码示例

```python
import hashlib

# 基本哈希计算
def sha256(data):
    return hashlib.sha256(data.encode()).hexdigest()

# 演示确定性
print(sha256("hello"))  # 永远是 2cf24dba...
print(sha256("hello"))  # 永远是 2cf24dba...

# 演示雪崩效应
print(sha256("hello"))   # 2cf24dba...
print(sha256("hello!"))  # 完全不同的值

# 演示不同长度输入 → 固定长度输出
print(len(sha256("a")))          # 64 字符（256 bits）
print(len(sha256("a" * 1000)))   # 64 字符（256 bits）
```

```solidity
// Solidity 中的哈希
contract HashExample {
    // keccak256 是以太坊使用的哈希函数
    function hash(string memory input) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(input));
    }

    // 验证哈希
    function verify(
        string memory input,
        bytes32 expectedHash
    ) public pure returns (bool) {
        return keccak256(abi.encodePacked(input)) == expectedHash;
    }
}
```

### 哈希在区块链中的应用

```
区块结构：

┌─────────────────────────────────────────┐
│              Block #100                  │
├─────────────────────────────────────────┤
│  Previous Hash: 0x7a9d63e7...           │◀── 上一个区块的哈希
│  Timestamp: 1640000000                  │
│  Nonce: 12839471923                     │
│  Merkle Root: 0x3f5e8a2b...             │◀── 所有交易的哈希聚合
│  Transactions: [...]                    │
└─────────────────────────────────────────┘
          │
          │ Hash(整个区块头)
          ▼
     Block Hash: 0x000000abc...           ◀── 这就是"区块哈希"
          │
          │
          ▼
┌─────────────────────────────────────────┐
│              Block #101                  │
├─────────────────────────────────────────┤
│  Previous Hash: 0x000000abc...          │◀── 引用上面的区块哈希
│  ...                                    │
└─────────────────────────────────────────┘
```

### 为什么改不了历史？

```
假设攻击者想篡改 Block #100 中的一笔交易：

1. 交易改了 → Merkle Root 变了
2. Merkle Root 变了 → Block #100 的哈希变了
3. Block #100 哈希变了 → Block #101 的 Previous Hash 不对了
4. 要修复 #101 → 需要重新计算 #101 的哈希
5. #101 改了 → #102 又不对了
6. ...

结论：改一个区块 = 要改它后面的所有区块
这需要超过全网 50% 的算力（PoW）或质押（PoS）
```

---

## 新手最常踩的 3 个坑

### 坑 1：用哈希存密码但没加"盐"

```python
# ❌ 危险做法
password_hash = sha256(password)
# 问题：相同密码哈希相同，可用彩虹表破解

# ✅ 正确做法：加盐
import os
import hashlib

salt = os.urandom(16)  # 随机盐
password_hash = hashlib.pbkdf2_hmac(
    'sha256',
    password.encode(),
    salt,
    100000  # 迭代次数
)
# 存储：salt + password_hash
```

### 坑 2：以为哈希值能"解密"

**场景**：
```
用户："我忘记密码了，你能根据数据库里的哈希告诉我密码吗？"

回答："不可能。哈希是单向的，无法还原。
      只能重置密码。"
```

### 坑 3：混淆不同的哈希函数

```solidity
// 以太坊中的易混淆点：

// keccak256 ≠ SHA-3
// 以太坊用的是 keccak256，这是 SHA-3 的前身
// 标准化后的 SHA-3 做了小改动，所以结果不同

// abi.encode vs abi.encodePacked
keccak256(abi.encode(a, b))       // 有填充，更安全
keccak256(abi.encodePacked(a, b)) // 紧密打包，可能碰撞

// 例如：
// abi.encodePacked("ab", "c") == abi.encodePacked("a", "bc")
// 都是 "abc"！
```

---

## 流程图定位

哈希在区块链数据结构中的位置：

```
┌─────────────────────────────────────────────────────────────────┐
│                    区块链数据结构                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  交易层：                                                        │
│  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐               │
│  │  TX 1  │  │  TX 2  │  │  TX 3  │  │  TX 4  │               │
│  └───┬────┘  └───┬────┘  └───┬────┘  └───┬────┘               │
│      │           │           │           │                      │
│      ▼           ▼           ▼           ▼                      │
│   Hash(TX1)  Hash(TX2)  Hash(TX3)  Hash(TX4) ◀── 【哈希层1】   │
│      │           │           │           │                      │
│      └─────┬─────┘           └─────┬─────┘                      │
│            ▼                       ▼                            │
│       Hash(H1+H2)             Hash(H3+H4)    ◀── 【哈希层2】    │
│            │                       │                            │
│            └───────────┬───────────┘                            │
│                        ▼                                        │
│                   Merkle Root                ◀── 【Merkle根】   │
│                        │                                        │
│                        ▼                                        │
│               ┌─────────────────┐                              │
│               │    Block Header │            ◀── 【区块头】     │
│               └────────┬────────┘                              │
│                        │                                        │
│                        ▼                                        │
│                   Block Hash                 ◀── 【区块哈希】   │
│                        │                                        │
│                        ▼                                        │
│                 Next Block's                                    │
│                 Previous Hash                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 自测题

### 基础题

1. **判断题**：两个不同的输入不可能产生相同的 SHA-256 哈希值。（ ）
   <details>
   <summary>答案</summary>
   错误。理论上碰撞一定存在（输入无限，输出有限）。但对于 SHA-256，找到碰撞在计算上是不可行的（需要约 2^128 次操作）。
   </details>

2. **选择题**：SHA-256 的输出长度是？
   - A. 128 bits
   - B. 256 bits
   - C. 512 bits
   - D. 取决于输入长度
   <details>
   <summary>答案</summary>
   B. 256 bits（64 个十六进制字符，32 字节）
   </details>

3. **填空题**：哈希函数的"雪崩效应"是指：输入改变 ______ 个 bit，输出会改变约 ______ 的 bits。
   <details>
   <summary>答案</summary>
   1；50%（一半）
   </details>

### 编码题

4. 在 Solidity 中，如何安全地计算两个字符串拼接后的哈希？

   <details>
   <summary>答案</summary>

   ```solidity
   // ❌ 不安全：可能碰撞
   function unsafeHash(string memory a, string memory b) public pure returns (bytes32) {
       return keccak256(abi.encodePacked(a, b));
       // "ab" + "c" 和 "a" + "bc" 会产生相同结果！
   }

   // ✅ 安全：使用 abi.encode
   function safeHash(string memory a, string memory b) public pure returns (bytes32) {
       return keccak256(abi.encode(a, b));
       // 会添加长度前缀，避免碰撞
   }
   ```
   </details>

---

## 延伸阅读

- 相关：[Merkle 树](13-merkle-tree.md)
- 相关：[PoW](07-pow.md) - 哈希在挖矿中的应用
- 工具：[在线 SHA-256 计算器](https://emn178.github.io/online-tools/sha256.html)
