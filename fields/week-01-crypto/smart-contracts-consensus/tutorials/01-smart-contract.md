# 智能合约（Smart Contract）

## 一句话大白话

**智能合约就是一个"自动售货机"**：你投币（发送交易），它自动吐出商品（执行代码），全程不需要人工干预，也没人能阻止或篡改这个过程。

---

## 它解决什么问题

### 传统方式的痛点

想象一下买二手房的场景：
1. 买家怕付了钱，卖家不过户
2. 卖家怕过了户，买家不付钱
3. 于是需要中介/公证处/银行做担保
4. 中介要收费、要时间、还可能跑路

### 智能合约的解决方案

```
传统方式：                        智能合约方式：

买家 ──付款──▶ 中介 ──付款──▶ 卖家   买家 ──付款──▶ ┌─────────┐
卖家 ──过户──▶ 中介 ──过户──▶ 买家              │  智能  │ ──自动执行──▶ 双方
                                              │  合约  │
     需要信任中介                  └─────────┘
     中介可能作恶                       只需要信任代码
                                       代码不会作恶
```

**核心价值**：用代码代替中间人，实现"代码即法律"（Code is Law）。

---

## 什么时候用 / 什么时候别用

### ✅ 适合用智能合约的场景

| 场景 | 原因 |
|------|------|
| 众筹 | 自动处理达标/退款逻辑，无需信任项目方 |
| 代币发行 | 发行量、转账规则写死在代码里，透明可验证 |
| 去中心化交易 | 交易撮合、资金托管全自动，无跑路风险 |
| DAO 投票 | 投票结果自动执行，无人能篡改 |
| NFT | 数字资产所有权上链，不可伪造 |
| 多签钱包 | 多人共管资金，规则由代码保证 |

### ❌ 不适合用智能合约的场景

| 场景 | 原因 |
|------|------|
| 需要频繁修改规则 | 合约部署后不可修改 |
| 涉及链下信息 | 合约无法直接获取链外数据 |
| 需要高隐私 | 合约代码和状态对所有人可见 |
| 低价值高频交易 | Gas 费可能比交易本身还贵 |
| 需要撤销/退款 | 执行后不可逆 |

---

## 它不是什么（常见混淆点）

### ❌ 智能合约 ≠ 人工智能

"智能"这个词容易误导。智能合约一点都不"智能"，它：
- 不会学习
- 不会推理
- 不会判断
- 只是**严格按代码执行**

更准确的名字应该是"**自动化合约**"或"**自执行合约**"。

### ❌ 智能合约 ≠ 法律合同

| 法律合同 | 智能合约 |
|----------|----------|
| 用自然语言 | 用编程语言 |
| 可以有模糊条款 | 必须精确定义 |
| 靠法院强制执行 | 靠代码自动执行 |
| 可以撤销/修改 | 部署后不可更改 |
| 可以解释 | 只看代码逻辑 |

### ❌ 智能合约 ≠ 普通程序

| 普通程序 | 智能合约 |
|----------|----------|
| 跑在某台服务器上 | 跑在所有节点上 |
| 可以随时更新 | 部署后不可修改 |
| 运行免费（服务器自付） | 每次执行要付 Gas |
| 可以访问网络/文件 | 只能访问链上数据 |
| 出错可以重来 | 执行后不可逆 |

---

## 最小例子

### 一个最简单的"存钱罐"合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 这是一个存钱罐合约
contract PiggyBank {
    // 存钱罐主人
    address public owner;

    // 构造函数：创建合约时执行一次
    constructor() {
        owner = msg.sender;  // 谁部署谁是主人
    }

    // 存钱：任何人都可以存
    function deposit() public payable {
        // payable 表示这个函数可以接收以太币
        // 钱自动存入合约地址
    }

    // 砸罐取钱：只有主人能取
    function smash() public {
        require(msg.sender == owner, "Only owner can smash!");

        // 把合约里所有的钱转给主人
        payable(owner).transfer(address(this).balance);
    }

    // 查看存了多少钱
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
```

### 这个合约能做什么？

1. **部署合约**：你变成"主人"
2. **任何人存钱**：调用 `deposit()` 并附带 ETH
3. **查看余额**：调用 `getBalance()`
4. **主人取钱**：调用 `smash()` 取走所有钱

### 执行流程

```
用户A调用 deposit() 并发送 1 ETH
        │
        ▼
┌───────────────────────────────┐
│   PiggyBank 合约               │
│   balance: 1 ETH              │
│   owner: 0x123...（部署者）    │
└───────────────────────────────┘
        │
用户B调用 deposit() 并发送 2 ETH
        │
        ▼
┌───────────────────────────────┐
│   PiggyBank 合约               │
│   balance: 3 ETH              │
│   owner: 0x123...             │
└───────────────────────────────┘
        │
主人调用 smash()
        │
        ▼
┌───────────────────────────────┐
│   PiggyBank 合约               │
│   balance: 0 ETH              │
│   owner: 0x123...             │
└───────────────────────────────┘
        │
        ▼
    3 ETH 转到主人账户
```

---

## 新手最常踩的 3 个坑

### 坑 1：以为合约可以随便改

**错误想法**："代码有 bug？改一下重新部署就行。"

**现实**：
- 合约部署后，代码**永远不能修改**
- 只能部署一个新合约，但旧合约里的钱和数据不会自动迁移
- 解决方案：使用"可升级合约"模式（代理模式），但这增加了复杂性

**教训**：部署前必须充分测试！

### 坑 2：以为合约里的钱很安全

**错误想法**："钱在合约里，没有私钥谁也拿不走。"

**现实**：
- 合约代码有漏洞 = 钱被盗
- 2016 年 The DAO 被黑，损失 6000 万美元
- 常见漏洞：重入攻击、整数溢出、权限控制不当

**教训**：
- 用成熟的库（如 OpenZeppelin）
- 请专业团队审计
- 先在测试网充分测试

### 坑 3：忽略 Gas 成本

**错误想法**："功能先实现，Gas 以后再优化。"

**现实**：
- 一个写得不好的循环可能消耗几百美元 Gas
- 用户可能因为 Gas 太贵而放弃使用
- Gas 优化是智能合约开发的核心技能

**教训**：
- 避免在链上存储大量数据
- 避免循环遍历数组
- 使用 mapping 代替数组查找

---

## 流程图定位

在整体流程中，智能合约是**应用层和链的交互接口**：

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  用户/DApp  ◀──────▶  【智能合约】  ◀──────▶  区块链状态        │
│                           │                                     │
│                           │                                     │
│                     ┌─────▼─────┐                              │
│                     │   EVM     │                              │
│                     │  执行引擎  │                              │
│                     └───────────┘                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

智能合约是用户与区块链交互的"翻译官"：
- 用户发送交易 → 合约解析并执行
- 合约修改状态 → 被打包进区块
- 共识算法保证 → 状态变更被全网认可

---

## 自测题

### 基础题

1. **判断题**：智能合约部署后可以修改代码。（ ）
   <details>
   <summary>答案</summary>
   错误。智能合约部署后代码不可修改，只能通过代理模式实现"可升级"。
   </details>

2. **选择题**：智能合约最适合处理以下哪种场景？
   - A. 需要每天更新规则的会员系统
   - B. 需要多方共同管理的资金池
   - C. 需要存储大量用户隐私数据
   - D. 需要频繁与外部 API 交互
   <details>
   <summary>答案</summary>
   B。多方共管资金池是智能合约的典型应用场景，规则透明、自动执行。
   </details>

### 思考题

3. **场景题**：你要做一个"对赌合约"——A 和 B 各押 1 ETH 赌明天股价涨跌，赢家拿走全部。这个合约的主要技术挑战是什么？

   <details>
   <summary>答案</summary>
   主要挑战是**如何获取链外数据（股价）**。智能合约无法直接访问互联网，需要使用预言机（Oracle）服务（如 Chainlink）来获取可信的链外数据。这也引出了"预言机问题"——如何保证链外数据的准确性和不可篡改性。
   </details>

---

## 延伸阅读

- 下一篇：[Solidity 基础](02-solidity-basics.md) - 学习如何编写智能合约
- 相关：[Gas 和交易费用](03-gas-and-fees.md) - 了解执行合约的成本
- 相关：[EVM](05-evm.md) - 了解合约是如何被执行的
