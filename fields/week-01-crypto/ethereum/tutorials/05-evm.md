# EVM（以太坊虚拟机）

## 一句话大白话

**EVM 就是一台「世界计算机」——全球数万台电脑同时运行完全相同的程序，得到完全相同的结果。**

就像全世界的计算器，你输入 `1+1`，不管在北京还是纽约，结果都是 `2`。EVM 保证了以太坊网络中每台机器执行同一段代码的结果完全一致。

---

## 它解决什么问题

### 核心问题：如何保证全网数万台电脑执行结果一致？

分布式系统的噩梦：
- 不同操作系统（Windows、Linux、Mac）
- 不同处理器架构（x86、ARM）
- 不同编程语言和编译器
- 浮点数运算在不同机器上可能有微小差异

**EVM 的解决方案**：
定义一套统一的虚拟机规范，所有节点都运行这个虚拟机，输入相同的指令，必然得到相同的结果。

### 设计目标

| 目标 | 实现方式 |
|------|---------|
| **确定性** | 相同输入必产生相同输出，没有随机性 |
| **隔离性** | 合约只能访问自己的数据，沙箱执行 |
| **可计量** | 每个操作都有明确的 Gas 成本 |
| **安全性** | 限制危险操作，防止恶意代码 |

---

## 什么时候用 / 什么时候别用

### 理解 EVM 对你有什么用？

| 你是... | 为什么要了解 EVM |
|--------|-----------------|
| 普通用户 | 理解为什么交易需要 Gas，为什么有些操作贵 |
| 合约开发者 | 写出更高效、更省 Gas 的代码 |
| 安全研究员 | 理解底层才能发现漏洞 |
| DApp 开发者 | 知道链上能做什么、不能做什么 |

### EVM 的局限性

| 局限 | 原因 | 替代方案 |
|------|------|---------|
| 计算能力有限 | 所有节点都要执行，太复杂会太慢 | 链下计算 + 链上验证 |
| 没有浮点数 | 浮点数在不同机器上可能不一致 | 使用定点数（如 18位小数） |
| 无法访问外部数据 | 保证确定性 | 使用预言机（Oracle） |
| 存储昂贵 | 状态要永久保存在所有节点 | 链下存储 + 链上哈希 |

---

## 它不是什么

### 常见误解

| 误解 | 真相 |
|------|------|
| 「EVM 是一台真实的计算机」 | 是软件模拟的虚拟机，运行在真实电脑上 |
| 「EVM 只能运行 Solidity」 | 能运行任何编译成 EVM 字节码的语言（Vyper、Yul 等） |
| 「EVM 很强大」 | 故意设计得简单、受限，以保证安全和确定性 |
| 「其他链不用 EVM」 | 很多链兼容 EVM（Polygon、BSC、Arbitrum 等） |
| 「EVM 是以太坊独有的」 | EVM 已成为行业标准，有几十条链使用 |

---

## 最小例子

### EVM 架构概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                           EVM 架构                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  输入                                                               │
│  ├─ 交易数据（to, value, data）                                     │
│  ├─ 当前区块信息（number, timestamp, coinbase）                     │
│  └─ 世界状态（所有账户的余额、代码、存储）                           │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      执行环境                                │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │   │
│  │  │  代码   │  │  栈     │  │  内存   │  │ 存储    │        │   │
│  │  │(Code)   │  │(Stack)  │  │(Memory) │  │(Storage)│        │   │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │   │
│  │       │            │            │            │              │   │
│  │       │  最多1024个  │  临时的    │  永久的   │              │   │
│  │       │  256位元素   │  按需扩展   │  持久化   │              │   │
│  │       │            │  执行后清空  │  最贵！   │              │   │
│  │       v            v            v            v              │   │
│  │  ┌─────────────────────────────────────────────────┐        │   │
│  │  │               程序计数器 (PC)                    │        │   │
│  │  │           指向当前执行的指令位置                  │        │   │
│  │  └─────────────────────────────────────────────────┘        │   │
│  │                          │                                  │   │
│  │                          v                                  │   │
│  │  ┌─────────────────────────────────────────────────┐        │   │
│  │  │                Gas 计量器                        │        │   │
│  │  │            每执行一条指令就扣减                   │        │   │
│  │  └─────────────────────────────────────────────────┘        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  输出                                                               │
│  ├─ 新的世界状态（余额变化、存储变化）                              │
│  ├─ 日志（Events）                                                 │
│  └─ 返回数据 / 错误信息                                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 四种数据存储区域

```
┌─────────────────────────────────────────────────────────────────────┐
│  1. 栈 (Stack)                                                      │
├─────────────────────────────────────────────────────────────────────┤
│  - 最多 1024 个元素                                                 │
│  - 每个元素 256 位（32 字节）                                        │
│  - 后进先出（LIFO）                                                 │
│  - 所有计算都在栈上进行                                             │
│  - 免费，但深度有限                                                 │
│                                                                     │
│  例子：计算 3 + 5                                                   │
│  PUSH1 3    栈: [3]                                                │
│  PUSH1 5    栈: [3, 5]                                             │
│  ADD        栈: [8]  (弹出两个，压入结果)                           │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  2. 内存 (Memory)                                                   │
├─────────────────────────────────────────────────────────────────────┤
│  - 临时的，每次调用重新开始                                         │
│  - 按字节寻址，按需扩展                                             │
│  - 用于临时数据、函数参数、返回值                                    │
│  - Gas 成本随大小增加（二次方增长）                                  │
│                                                                     │
│  操作码：MLOAD, MSTORE, MSTORE8                                     │
│  成本：3 Gas 基础 + 扩展内存的成本                                   │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  3. 存储 (Storage)                                                  │
├─────────────────────────────────────────────────────────────────────┤
│  - 永久的，保存在区块链上                                           │
│  - 键值对结构，每个键和值都是 256 位                                 │
│  - 最贵的操作！                                                     │
│                                                                     │
│  操作码：SLOAD, SSTORE                                              │
│  成本：                                                             │
│  - SLOAD: 2100 Gas（冷读取）/ 100 Gas（热读取）                     │
│  - SSTORE: 20000 Gas（新值）/ 5000 Gas（修改）                      │
│  - 删除可退还部分 Gas                                               │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  4. Calldata                                                        │
├─────────────────────────────────────────────────────────────────────┤
│  - 只读的交易输入数据                                               │
│  - 来自交易的 data 字段                                             │
│  - 不能修改                                                         │
│                                                                     │
│  操作码：CALLDATALOAD, CALLDATASIZE, CALLDATACOPY                   │
│  成本：便宜（3 Gas 基础）                                           │
└─────────────────────────────────────────────────────────────────────┘
```

### 常见操作码（Opcodes）

```
类别          操作码              Gas    说明
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
栈操作
             PUSH1-PUSH32        3      压入 1-32 字节到栈
             POP                 2      弹出栈顶
             DUP1-DUP16          3      复制栈中元素
             SWAP1-SWAP16        3      交换栈中元素

算术运算
             ADD                 3      加法
             SUB                 3      减法
             MUL                 5      乘法
             DIV                 5      除法
             MOD                 5      取模
             EXP                 10*    指数运算（按指数大小收费）

比较/逻辑
             LT, GT, EQ          3      小于、大于、等于
             AND, OR, XOR        3      位运算
             NOT                 3      取反
             ISZERO              3      是否为零

内存操作
             MLOAD               3*     从内存读取
             MSTORE              3*     写入内存（32字节）
             MSTORE8             3*     写入内存（1字节）

存储操作
             SLOAD               2100   从存储读取（冷）
             SSTORE              20000  写入存储（新值）

控制流
             JUMP                8      无条件跳转
             JUMPI               10     条件跳转
             STOP                0      停止执行
             RETURN              0*     返回数据并停止
             REVERT              0*     回滚并返回错误

环境信息
             CALLER              2      调用者地址
             CALLVALUE           2      发送的 ETH 数量
             BALANCE             2600   查询余额（冷）
             TIMESTAMP           2      当前区块时间戳
             NUMBER              2      当前区块号

合约交互
             CALL                2600*  调用外部合约
             DELEGATECALL        2600*  委托调用
             STATICCALL          2600*  静态调用（只读）
             CREATE              32000  创建合约
             SELFDESTRUCT        5000*  销毁合约
```

### 字节码执行示例

```solidity
// Solidity 代码
function add(uint a, uint b) public pure returns (uint) {
    return a + b;
}
```

编译后的字节码执行流程：

```
假设调用 add(3, 5)
交易 data: 0x771602f7  <- 函数选择器 (keccak256("add(uint256,uint256)") 的前4字节)
           0000000000000000000000000000000000000000000000000000000000000003  <- 参数 a
           0000000000000000000000000000000000000000000000000000000000000005  <- 参数 b

执行步骤（简化）：
┌──────────────────────────────────────────────────────────────────────┐
│ PC   │ 操作码          │ 栈状态              │ 说明                  │
├──────┼─────────────────┼────────────────────┼───────────────────────┤
│ 0x00 │ PUSH1 0x80      │ [0x80]             │ 内存指针初始化         │
│ 0x02 │ PUSH1 0x40      │ [0x80, 0x40]       │                       │
│ 0x04 │ MSTORE          │ []                 │ 存储空闲内存指针       │
│ ...  │ (检查函数选择器) │                    │                       │
│ 0x20 │ CALLDATALOAD    │ [3]                │ 加载参数 a            │
│ 0x22 │ CALLDATALOAD    │ [3, 5]             │ 加载参数 b            │
│ 0x24 │ ADD             │ [8]                │ 计算 3 + 5            │
│ 0x25 │ RETURN          │ []                 │ 返回结果 8            │
└──────────────────────────────────────────────────────────────────────┘
```

### 用工具查看字节码

```javascript
const { ethers } = require('ethers');

// 连接到以太坊
const provider = new ethers.JsonRpcProvider('YOUR_RPC_URL');

// 获取合约字节码
async function getContractCode() {
    // USDT 合约地址
    const address = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    const code = await provider.getCode(address);

    console.log('字节码长度:', code.length, '字符');
    console.log('字节码前100字符:', code.slice(0, 100));
}

// 反编译字节码（使用在线工具更方便）
// - https://ethervm.io/decompile
// - https://etherscan.io 的 "Contract" -> "Read as Proxy"
```

---

## 新手最常踩的 3 个坑

### 坑 1：不理解 Storage 和 Memory 的区别

```solidity
contract StorageVsMemory {
    uint256[] public data;  // 存储在 Storage

    // 错误：意外修改了原数组
    function wrongWay() public {
        uint256[] storage arr = data;  // arr 是 data 的引用！
        arr.push(1);  // 修改 arr 就是修改 data
    }

    // 正确：只读取，不修改
    function rightWay() public view returns (uint256) {
        uint256[] memory arr = data;  // arr 是 data 的副本
        // 对 arr 的修改不影响 data
        return arr.length;
    }
}
```

**记忆口诀**：
```
Storage = 硬盘（永久，贵）
Memory = 内存（临时，便宜）
Calldata = 只读参数（最便宜）

默认情况：
- 状态变量 → Storage
- 函数参数 → Calldata（external函数）或 Memory
- 局部变量 → Memory（除非显式指定 storage）
```

### 坑 2：Gas 估算失败的原因

```solidity
contract GasEstimationIssue {
    uint256 public value;

    function riskyFunction(uint256 x) public {
        // 这个条件在 estimateGas 时可能为 true
        // 但在实际执行时可能为 false
        if (block.timestamp % 2 == 0) {
            value = x;  // SSTORE: 20000 Gas
        } else {
            // 什么都不做: 几乎不耗 Gas
        }
    }
}

// 问题：
// 1. estimateGas 使用当前区块状态模拟
// 2. 实际执行时状态可能已改变
// 3. 导致估算的 Gas 和实际需要的 Gas 不同
```

**建议**：
- 对于状态依赖的操作，预留更多 Gas 余量
- 使用 `try/catch` 处理可能的失败
- 理解「模拟」和「实际执行」的区别

### 坑 3：栈溢出（Stack Too Deep）

```solidity
// 编译错误：Stack too deep
contract StackTooDeep {
    function tooManyLocals(
        uint a, uint b, uint c, uint d,
        uint e, uint f, uint g, uint h
    ) public pure returns (uint) {
        uint i = a + b;
        uint j = c + d;
        uint k = e + f;
        uint l = g + h;
        uint m = i + j;
        uint n = k + l;
        uint o = m + n;  // 错误！局部变量太多
        return o;
    }
}
```

**原因**：
- EVM 栈最多访问前 16 个元素
- 太多局部变量会导致无法访问

**解决方案**：
```solidity
// 方法1：使用结构体打包变量
struct Params {
    uint a; uint b; uint c; uint d;
}

// 方法2：拆分函数
function part1(uint a, uint b) internal pure returns (uint) {
    return a + b;
}

// 方法3：使用 memory 数组
function useArray(uint[] memory inputs) public pure returns (uint) {
    // ...
}
```

---

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────────┐
│                    以太坊交易生命周期                                │
└─────────────────────────────────────────────────────────────────────┘

                              用户发起交易
                                   │
                                   v
                            ┌──────────┐
                            │  广播    │
                            │  交易    │
                            └──────────┘
                                   │
                                   v
                            ┌──────────┐
                            │  打包    │
                            │  进区块  │
                            └──────────┘
                                   │
                                   v
            ┌──────────────────────────────────────────────┐
            │  [你在这里学习的内容]                         │
            │                                              │
            │  ┌────────────────────────────────────────┐  │
            │  │              EVM 执行                  │  │
            │  │  1. 加载合约代码                       │  │
            │  │  2. 初始化执行环境（栈、内存）          │  │
            │  │  3. 逐条执行操作码                     │  │
            │  │  4. 扣减 Gas                          │  │
            │  │  5. 更新状态/触发事件                  │  │
            │  │  6. 返回结果                          │  │
            │  └────────────────────────────────────────┘  │
            │                                              │
            │  如果成功：状态更新被保存                     │
            │  如果失败：状态回滚，Gas 仍被扣除            │
            │                                              │
            └──────────────────────────────────────────────┘
                                   │
                                   v
                            ┌──────────┐
                            │  状态    │
                            │  更新    │
                            └──────────┘
```

---

## 自测题

### 基础理解

1. **为什么 EVM 需要保证「确定性」？如果没有确定性会发生什么？**

<details>
<summary>参考答案</summary>

确定性意味着：相同的输入在任何节点上执行，必然得到相同的输出。

为什么必须确定性：
- 以太坊有数万个节点，每个节点独立执行所有交易
- 执行后，节点会对新状态达成共识
- 如果结果不一致，网络无法就「真实状态」达成共识
- 区块链会分叉，网络会崩溃

EVM 如何保证确定性：
- 没有随机数指令（需要用预言机或 VRF）
- 没有浮点数（用定点数代替）
- 不能访问外部数据（只能访问链上数据）
- 时间只精确到区块级别
</details>

2. **Storage、Memory、Calldata 的区别是什么？分别用于什么场景？**

<details>
<summary>参考答案</summary>

| 类型 | 生命周期 | 成本 | 使用场景 |
|------|---------|------|---------|
| Storage | 永久 | 最贵（SSTORE 20000 Gas） | 状态变量、需要持久化的数据 |
| Memory | 临时（调用期间） | 中等（按大小增长） | 临时变量、复杂计算 |
| Calldata | 临时（只读） | 最便宜 | 外部函数的参数 |

选择建议：
- 需要存到链上 → Storage
- 函数内临时用 → Memory
- 外部函数参数且不修改 → Calldata（省 Gas）

```solidity
function example(
    uint256[] calldata data  // calldata: 最省 Gas
) external {
    uint256[] memory copy = data;  // memory: 可修改的副本
    // storage 只能用于状态变量
}
```
</details>

3. **为什么说「SSTORE 是最贵的操作」？便宜和贵的差距有多大？**

<details>
<summary>参考答案</summary>

价格对比：
- ADD（加法）：3 Gas
- SLOAD（读存储）：2100 Gas
- SSTORE（写新值）：20000 Gas

差距：SSTORE 比 ADD 贵约 6666 倍！

为什么这么贵：
1. **永久性**：数据要永久存在区块链上
2. **冗余存储**：所有节点都要存储这份数据
3. **历史可追溯**：旧数据也要能查到

优化建议：
- 减少存储写入次数
- 批量更新而非单个更新
- 用事件记录历史（比存储便宜）
- 链下存储 + 链上哈希
</details>

### 进阶思考

4. **如果让你优化一个 NFT 铸造合约的 Gas 消耗，你会从哪些角度思考？**

<details>
<summary>参考答案</summary>

优化角度：

1. **存储优化**
   - 使用更小的数据类型（uint8 vs uint256）
   - 打包变量到同一存储槽
   - 使用事件代替存储记录历史

2. **批量操作**
   - 批量铸造（一次铸造多个）
   - 使用 ERC721A 等优化版标准

3. **延迟计算**
   - 懒铸造（Lazy Minting）：不预先铸造，购买时才铸造
   - 链下生成元数据，链上只存 URI

4. **代码优化**
   - 减少循环
   - 避免重复的外部调用
   - 使用 unchecked 块（确保不会溢出时）

5. **架构选择**
   - 考虑 L2 部署（Gas 更便宜）
   - 代理合约（减少部署成本）

具体技术：
```solidity
// 使用 ERC721A 批量铸造
function mint(uint256 quantity) external {
    _mint(msg.sender, quantity);  // 一次铸造多个，平摊 Gas
}

// 打包多个 uint8 到一个 uint256
// 一个存储槽可以放 32 个 uint8
```
</details>
