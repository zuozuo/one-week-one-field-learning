# 交易与签名

## 一句话大白话

**交易就是你在以太坊上「说话」的方式，签名就是证明「这话是你说的」——就像在转账单上按手印，银行才认这笔转账。**

没有签名的交易，就像没有盖章的支票，没人会执行它。

---

## 它解决什么问题

### 核心问题：如何在无需信任的环境中证明「是你授权的」？

传统银行转账：
- 密码验证：银行知道你的密码
- 短信验证：运营商知道你的手机号
- 身份核验：你要信任银行不会冒充你

**以太坊的解决方案**：
- 你用私钥签名交易
- 任何人都可以用你的地址验证签名
- 不需要信任任何第三方
- 数学保证：只有知道私钥的人才能生成有效签名

### 交易能做什么

| 交易类型 | to 地址 | data 字段 | value | 说明 |
|---------|---------|-----------|-------|------|
| 转账 ETH | 收款地址 | 空 | > 0 | 最简单的交易 |
| 调用合约 | 合约地址 | 函数调用数据 | 可选 | 与智能合约交互 |
| 部署合约 | 空 | 合约字节码 | 可选 | 创建新合约 |

---

## 什么时候用 / 什么时候别用

### 需要发交易的场景

| 操作 | 是否需要交易 | 原因 |
|------|-------------|------|
| 转账 ETH/代币 | 需要 | 改变了链上状态 |
| 调用合约的写函数 | 需要 | 改变了合约状态 |
| 部署合约 | 需要 | 创建了新账户 |
| 查询余额 | 不需要 | 只读操作 |
| 调用 view/pure 函数 | 不需要 | 不改变状态 |
| 查询区块信息 | 不需要 | 只读操作 |

### 签名的两种场景

```
1. 链上签名（发交易）
┌────────────────────────────────────────────────┐
│  签名交易 → 广播 → 打包 → 执行 → 改变状态      │
│  需要 Gas，需要等确认                          │
└────────────────────────────────────────────────┘

2. 链下签名（不发交易）
┌────────────────────────────────────────────────┐
│  签名消息 → 发给对方 → 对方验证签名            │
│  不需要 Gas，即时完成                          │
│  用途：登录验证、链下订单、Permit 授权         │
└────────────────────────────────────────────────┘
```

---

## 它不是什么

### 常见误解

| 误解 | 真相 |
|------|------|
| 「签名后交易就完成了」 | 签名只是第一步，还要广播、打包、执行 |
| 「交易失败签名就无效了」 | 签名是有效的，只是执行失败了 |
| 「签名会暴露私钥」 | 签名是用私钥生成的，但不包含私钥 |
| 「只有转账需要签名」 | 所有写操作都需要签名 |
| 「签名消息会花 Gas」 | 链下签名是免费的 |

---

## 最小例子

### 交易结构（EIP-1559 格式）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    以太坊交易结构                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  交易类型 (type): 2                    EIP-1559 交易                │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  链 ID (chainId): 1                 主网=1, Sepolia=11155111 │    │
│  │  Nonce: 5                           发送者的第6笔交易       │    │
│  │  Max Priority Fee: 2 Gwei           给验证者的小费          │    │
│  │  Max Fee: 50 Gwei                   愿付的最高价格          │    │
│  │  Gas Limit: 21000                   最多消耗的 Gas          │    │
│  │  To: 0x123...                       接收者地址              │    │
│  │  Value: 1000000000000000000         1 ETH (以 Wei 计)       │    │
│  │  Data: 0x                           附加数据（转账时为空）   │    │
│  │  Access List: []                    访问列表（优化用）       │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  签名 (Signature):                                          │    │
│  │  ├─ v: 1 或 0                       恢复标识符              │    │
│  │  ├─ r: 0xabc...                     签名的前32字节          │    │
│  │  └─ s: 0xdef...                     签名的后32字节          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 签名原理

```
┌─────────────────────────────────────────────────────────────────────┐
│                      签名流程                                        │
└─────────────────────────────────────────────────────────────────────┘

步骤 1：准备交易数据
┌─────────────────────────────────┐
│  交易内容                       │
│  {nonce, gasPrice, to, value...}│
└─────────────────────────────────┘
              │
              v
步骤 2：RLP 编码 + Keccak256 哈希
┌─────────────────────────────────┐
│  交易哈希                       │
│  0x7b3d8f4e2a1c...              │
└─────────────────────────────────┘
              │
              v
步骤 3：用私钥对哈希进行 ECDSA 签名
┌─────────────────────────────────┐
│  私钥: 0x4c0883a691...         │
│           +                     │
│  交易哈希                       │
│           ↓                     │
│  签名 (r, s, v)                 │
└─────────────────────────────────┘
              │
              v
步骤 4：组装完整交易
┌─────────────────────────────────┐
│  原始交易 + 签名                │
│  = 可广播的签名交易             │
└─────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────┐
│                      验证流程                                        │
└─────────────────────────────────────────────────────────────────────┘

任何人收到签名交易后：
┌─────────────────────────────────┐
│  输入：签名 (r, s, v) + 交易哈希│
│           ↓                     │
│  ECDSA 恢复算法                 │
│           ↓                     │
│  输出：签名者的公钥/地址        │
└─────────────────────────────────┘
              │
              v
        和 from 地址对比
              │
      ┌───────┴───────┐
      v               v
   匹配 ✓          不匹配 ✗
  交易有效         交易无效
```

### JavaScript 示例：发送交易

```javascript
const { ethers } = require('ethers');

async function sendTransaction() {
    // 1. 连接到网络
    const provider = new ethers.JsonRpcProvider('YOUR_RPC_URL');

    // 2. 创建钱包（带私钥）
    const wallet = new ethers.Wallet('YOUR_PRIVATE_KEY', provider);

    // 3. 构造交易
    const tx = {
        to: '0x接收者地址',
        value: ethers.parseEther('0.1'),  // 0.1 ETH
        // 以下参数通常由钱包自动填充
        // nonce: await wallet.getNonce(),
        // gasLimit: 21000,
        // maxFeePerGas: ethers.parseUnits('50', 'gwei'),
        // maxPriorityFeePerGas: ethers.parseUnits('2', 'gwei'),
    };

    // 4. 签名并发送（ethers 会自动签名）
    const txResponse = await wallet.sendTransaction(tx);
    console.log('交易哈希:', txResponse.hash);

    // 5. 等待确认
    const receipt = await txResponse.wait();
    console.log('区块号:', receipt.blockNumber);
    console.log('Gas 消耗:', receipt.gasUsed.toString());
}
```

### JavaScript 示例：签名消息（链下签名）

```javascript
const { ethers } = require('ethers');

async function signMessage() {
    const wallet = new ethers.Wallet('YOUR_PRIVATE_KEY');

    // 1. 签名普通消息
    const message = 'Hello, Ethereum!';
    const signature = await wallet.signMessage(message);
    console.log('签名:', signature);

    // 2. 验证签名（任何人都可以做）
    const recoveredAddress = ethers.verifyMessage(message, signature);
    console.log('签名者地址:', recoveredAddress);
    console.log('验证通过:', recoveredAddress === wallet.address);
}

// 常见用途：网站登录
async function loginWithEthereum() {
    // 网站给你一个随机消息
    const nonce = 'Login to MyApp - Nonce: 123456';

    // 你用钱包签名这个消息
    const signature = await wallet.signMessage(nonce);

    // 网站验证签名，确认你拥有这个地址
    // 无需密码，无需注册！
}
```

### JavaScript 示例：调用合约

```javascript
const { ethers } = require('ethers');

async function callContract() {
    const provider = new ethers.JsonRpcProvider('YOUR_RPC_URL');
    const wallet = new ethers.Wallet('YOUR_PRIVATE_KEY', provider);

    // USDT 合约
    const usdtAddress = '0xdAC17F958D2ee523a2206206994597C13D831ec7';
    const usdtAbi = [
        'function transfer(address to, uint256 amount) returns (bool)',
        'function balanceOf(address owner) view returns (uint256)',
    ];

    const usdt = new ethers.Contract(usdtAddress, usdtAbi, wallet);

    // 读取操作（不需要签名）
    const balance = await usdt.balanceOf(wallet.address);
    console.log('余额:', balance.toString());

    // 写入操作（需要签名，ethers 自动处理）
    const tx = await usdt.transfer(
        '0x接收者地址',
        1000000  // USDT 有 6 位小数，这是 1 USDT
    );
    await tx.wait();
    console.log('转账完成');
}
```

### 交易数据（data）的编码

```
调用函数: transfer(address to, uint256 amount)
参数: (0x123..., 100)

编码过程：
┌─────────────────────────────────────────────────────────────────────┐
│  1. 函数选择器 (4 字节)                                              │
│     keccak256("transfer(address,uint256)") 的前 4 字节              │
│     = 0xa9059cbb                                                     │
├─────────────────────────────────────────────────────────────────────┤
│  2. 参数编码 (每个 32 字节)                                          │
│     地址: 0x000000000000000000000000123456789...（左边补零到32字节）  │
│     数量: 0x0000000000000000000000000000000000000000000000000000000064│
├─────────────────────────────────────────────────────────────────────┤
│  3. 拼接                                                            │
│     data = 0xa9059cbb                                               │
│            000000000000000000000000123456789...                     │
│            0000000000000000000000000000000000000000000000000000000064│
└─────────────────────────────────────────────────────────────────────┘

用 ethers.js 编码：
const iface = new ethers.Interface(['function transfer(address,uint256)']);
const data = iface.encodeFunctionData('transfer', ['0x123...', 100]);
```

---

## 新手最常踩的 3 个坑

### 坑 1：Nonce 问题导致交易卡住

**场景**：
```
你发了 3 笔交易：
- Nonce 0: 已确认 ✓
- Nonce 1: 正在等待... (Gas 设太低)
- Nonce 2: 永远不会执行！(因为 Nonce 1 还没完成)
```

**解决方案**：
```javascript
// 方法1：加速 Nonce 1 的交易（发送相同 Nonce、更高 Gas Price 的新交易）
const speedUpTx = {
    to: '0x...',          // 和原交易相同
    value: originalValue,  // 和原交易相同
    nonce: 1,             // 必须相同！
    maxFeePerGas: higherFee,  // 提高 Gas
    maxPriorityFeePerGas: higherPriority,
};

// 方法2：取消交易（发送相同 Nonce、给自己转 0 ETH）
const cancelTx = {
    to: wallet.address,   // 给自己
    value: 0,             // 0 ETH
    nonce: 1,             // 相同 Nonce
    maxFeePerGas: higherFee,
};
```

### 坑 2：签名消息被钓鱼利用

**危险场景**：
```
恶意网站让你签名一个看似无害的消息：
"Login to verify your account"

但实际上这是一个 Permit 签名或授权签名！
签名后，攻击者可以用这个签名转走你的代币！
```

**如何防范**：
```
1. 只在信任的网站签名
2. 仔细阅读签名内容
3. 注意 EIP-712 类型化数据签名
4. 使用硬件钱包（会显示签名内容）
5. 不签署你不理解的内容
```

**识别危险签名**：
```
安全的登录签名：
┌─────────────────────────────────────────┐
│  Sign this message to login to MyApp:   │
│  Nonce: 123456                          │
│  Timestamp: 1699999999                  │
└─────────────────────────────────────────┘

危险的 Permit 签名：
┌─────────────────────────────────────────┐
│  Permit USDC spending                   │
│  Spender: 0xAttacker...                 │  <- 授权给攻击者！
│  Value: 115792089237316...              │  <- 无限额度！
│  Deadline: 永不过期                      │
└─────────────────────────────────────────┘
```

### 坑 3：交易失败但 Gas 被扣

**常见原因**：
```
1. 合约执行 revert
   - require 条件不满足
   - 余额不足
   - 权限检查失败

2. Gas 不足
   - Gas Limit 设太低
   - 但已消耗的 Gas 不退！

3. Nonce 问题
   - 使用了已经用过的 Nonce
```

**预防措施**：
```javascript
// 1. 先模拟交易
try {
    await contract.transfer.staticCall(to, amount);  // 静态调用不消耗 Gas
    console.log('模拟成功，可以发送');
} catch (error) {
    console.log('模拟失败:', error.reason);
    // 不要发送！
}

// 2. 检查 Gas 估算
const estimated = await contract.transfer.estimateGas(to, amount);
console.log('预估 Gas:', estimated.toString());

// 3. 添加余量
const gasLimit = estimated * 120n / 100n;  // 加 20%
```

---

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────────┐
│                    以太坊交易生命周期                                │
└─────────────────────────────────────────────────────────────────────┘

       [你在这里学习的内容]
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  1. 构造交易                                                        │
│     - 填写 to, value, data 等字段                                   │
│     - 设置 Gas 参数                                                 │
│     - 确定 Nonce                                                    │
└─────────────────────────────────────────────────────────────────────┘
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  2. 签名交易                                                        │
│     - 用私钥对交易哈希签名                                           │
│     - 生成 (r, s, v) 签名值                                         │
│     - 组装成完整的签名交易                                           │
└─────────────────────────────────────────────────────────────────────┘
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  3. 广播交易                                                        │
│     - 发送到以太坊节点                                               │
│     - 节点验证签名和基本规则                                         │
│     - 传播到网络中的其他节点                                         │
└─────────────────────────────────────────────────────────────────────┘
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  4. 进入交易池 (Mempool)                                            │
│     - 等待被验证者选中                                               │
│     - 按 Gas Price 排序                                             │
└─────────────────────────────────────────────────────────────────────┘
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  5. 打包执行                                                        │
│     - 验证者把交易打包进区块                                         │
│     - EVM 执行交易                                                  │
│     - 更新状态                                                       │
└─────────────────────────────────────────────────────────────────────┘
              │
              v
┌─────────────────────────────────────────────────────────────────────┐
│  6. 确认完成                                                        │
│     - 区块被网络接受                                                 │
│     - 交易获得确认                                                   │
│     - 可在区块浏览器查看                                             │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 自测题

### 基础理解

1. **为什么说「签名不会暴露私钥」？签名的数学原理是什么？**

<details>
<summary>参考答案</summary>

签名使用 ECDSA（椭圆曲线数字签名算法）：

签名过程：
1. 用私钥 + 消息哈希 + 随机数，计算出签名 (r, s)
2. 签名本身不包含私钥

验证过程：
1. 用签名 (r, s) + 消息哈希，恢复出公钥
2. 对比恢复的公钥和声称的公钥

为什么安全：
- 从签名反推私钥需要解「离散对数问题」
- 这在数学上被认为是极其困难的（指数级时间复杂度）
- 目前没有已知的高效算法能破解

注意：
- 随机数必须真随机，否则可能泄露私钥（历史上有过这种漏洞）
- 同一个随机数签名两条不同消息会暴露私钥！
</details>

2. **Nonce 是什么？为什么它对安全性很重要？**

<details>
<summary>参考答案</summary>

Nonce 是账户发送交易的序号，从 0 开始递增。

作用：
1. **防止重放攻击**：没有 nonce，攻击者可以反复广播你的已签名交易
2. **保证顺序**：交易必须按 nonce 顺序执行
3. **交易唯一性**：同一账户的 nonce + 交易内容 = 唯一交易

安全重要性：
- 每个 nonce 只能用一次
- 用过的 nonce 不能再用
- 没有 nonce 的话，你转给 Alice 1 ETH 的交易可以被无限重放

应用：
- 取消交易：发送相同 nonce 的新交易
- 加速交易：发送相同 nonce、更高 gas 的交易
</details>

3. **链上签名和链下签名有什么区别？各自适用什么场景？**

<details>
<summary>参考答案</summary>

| 特性 | 链上签名（交易） | 链下签名（消息） |
|------|-----------------|-----------------|
| 是否上链 | 是 | 否 |
| 是否花 Gas | 是 | 否 |
| 执行时间 | 需要等区块确认 | 即时 |
| 状态改变 | 可以 | 不可以 |

链上签名适用场景：
- 转账
- 调用合约
- 部署合约
- 任何需要改变链上状态的操作

链下签名适用场景：
- 网站登录（Sign In With Ethereum）
- 链下订单（如 OpenSea 的订单）
- Permit 授权（ERC-20 Permit）
- 多签收集签名
- 任何需要证明身份但不改变状态的场景
</details>

### 进阶思考

4. **如果你要设计一个「无 Gas 交易」系统（用户不付 Gas，项目方付），你会怎么设计？**

<details>
<summary>参考答案</summary>

这叫「元交易」（Meta Transaction），设计思路：

1. **用户签名意图**（链下签名，不花 Gas）
   - 用户签名：「我要转 100 USDC 给 Alice」

2. **中继者提交交易**（中继者付 Gas）
   - 中继者收到签名
   - 中继者构造交易，调用合约
   - 中继者支付 Gas

3. **合约验证签名**
   - 合约验证签名有效
   - 合约执行转账
   - （可选）合约从用户扣除费用给中继者

实现方式：
- EIP-2771：受信任的转发者
- ERC-20 Permit：授权转账无需提前 approve

```solidity
// 简化的元交易合约
function executeMetaTx(
    address user,
    bytes calldata functionData,
    bytes calldata signature
) external {
    // 验证签名
    bytes32 hash = keccak256(abi.encodePacked(user, functionData, nonces[user]));
    require(recoverSigner(hash, signature) == user, "Invalid signature");

    nonces[user]++;

    // 执行调用（msg.sender 变成合约，但 _msgSender() 返回 user）
    (bool success,) = address(this).call(functionData);
    require(success);
}
```

实际应用：
- GSN（Gas Station Network）
- Biconomy
- OpenGSN
</details>
