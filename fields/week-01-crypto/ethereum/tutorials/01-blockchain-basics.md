# 区块链基础

## 一句话大白话

**区块链就是一个所有人都有副本的账本，任何人想改一条记录，全网都会知道并拒绝。**

想象全村人每人都有一本一模一样的账本，每次有人转账，全村人同时记录。如果有人想偷偷改自己的账本，其他999个人的账本都不同意，改了也没用。

---

## 它解决什么问题

### 核心问题：双花问题（Double Spending）

在数字世界里，复制一个文件太容易了。如果没有中心化机构（比如银行），你怎么确保别人发给你的「钱」不是复制的？

**传统解决方案**：找个大家都信任的中间人（银行）来记账
- 优点：简单高效
- 缺点：中间人可能作恶、倒闭、被审查

**区块链解决方案**：让所有人一起记账，多数人认可才算数
- 优点：去中心化、抗审查、透明
- 缺点：效率相对较低

### 使用场景

- **价值转移**：转账、支付（不需要银行）
- **存证**：证明某个数据在某个时间点存在
- **去中心化应用**：在区块链上运行的程序，没有人能关停

---

## 什么时候用 / 什么时候别用

### ✅ 适合使用区块链

| 场景 | 原因 |
|------|------|
| 不信任对方，但需要交易 | 区块链提供无需信任的交易环境 |
| 需要防篡改的记录 | 区块链的数据几乎不可能被修改 |
| 需要透明和可审计 | 所有交易公开可查 |
| 需要抗审查 | 没有单一实体能阻止交易 |

### ❌ 不适合使用区块链

| 场景 | 原因 |
|------|------|
| 需要高并发、低延迟 | 区块链速度相对慢（以太坊约15TPS） |
| 数据需要修改或删除 | 区块链数据几乎不可变 |
| 有可信的中心化方案 | 没必要增加复杂度 |
| 隐私敏感数据 | 公链数据完全公开 |

---

## 它不是什么

### 常见误解

| 误解 | 真相 |
|------|------|
| 「区块链 = 比特币」 | 比特币是区块链的一个应用，就像邮件是互联网的一个应用 |
| 「区块链是匿名的」 | 是「假名」而非匿名，地址和交易完全公开可追踪 |
| 「区块链不可能被攻击」 | 51%攻击、智能合约漏洞都是真实威胁 |
| 「区块链能解决所有信任问题」 | 只能解决链上数据的信任，链外数据（预言机问题）仍需信任 |
| 「区块链上的数据是加密的」 | 公链上的数据是公开透明的，任何人都能看 |

---

## 最小例子

### 一个简化的区块链结构

```
区块 0（创世区块）
┌─────────────────────────┐
│ 区块哈希: 0000abc...     │
│ 前一区块哈希: 无          │
│ 时间: 2015-07-30         │
│ 交易: [初始分配]          │
└─────────────────────────┘
           │
           v
区块 1
┌─────────────────────────┐
│ 区块哈希: 0000def...     │
│ 前一区块哈希: 0000abc... │  <- 指向上一个区块
│ 时间: 2015-07-30         │
│ 交易:                    │
│   - Alice -> Bob: 10 ETH │
│   - Charlie -> David: 5  │
└─────────────────────────┘
           │
           v
区块 2
┌─────────────────────────┐
│ 区块哈希: 0000ghi...     │
│ 前一区块哈希: 0000def... │
│ ...                      │
└─────────────────────────┘
```

### 为什么不可篡改？

```
假设有人想把区块1中的交易改掉：

原始: Alice -> Bob: 10 ETH
篡改: Alice -> Bob: 1 ETH （企图偷走9个ETH）

会发生什么：
1. 区块1的内容变了 -> 区块1的哈希变了（比如变成 0000xyz...）
2. 区块2引用的是 0000def... -> 和新哈希不匹配 -> 区块2无效
3. 区块3引用区块2 -> 也无效
4. 所有后续区块全部无效！

要让篡改生效，必须重新计算区块1之后所有区块的哈希
在 PoS 系统中，这意味着要控制大量质押的 ETH
在经济上完全不可行
```

### 用 JavaScript 模拟一个最简区块链

```javascript
const crypto = require('crypto');

// 计算哈希
function hash(data) {
    return crypto.createHash('sha256').update(data).digest('hex');
}

// 区块结构
class Block {
    constructor(index, previousHash, transactions, timestamp = Date.now()) {
        this.index = index;
        this.previousHash = previousHash;
        this.transactions = transactions;
        this.timestamp = timestamp;
        this.hash = this.calculateHash();
    }

    calculateHash() {
        return hash(
            this.index +
            this.previousHash +
            JSON.stringify(this.transactions) +
            this.timestamp
        );
    }
}

// 简单的区块链
class SimpleBlockchain {
    constructor() {
        this.chain = [this.createGenesisBlock()];
    }

    createGenesisBlock() {
        return new Block(0, '0', ['Genesis Block'], 0);
    }

    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }

    addBlock(transactions) {
        const newBlock = new Block(
            this.chain.length,
            this.getLatestBlock().hash,
            transactions
        );
        this.chain.push(newBlock);
        return newBlock;
    }

    // 验证链的完整性
    isChainValid() {
        for (let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];

            // 检查当前区块的哈希是否正确
            if (currentBlock.hash !== currentBlock.calculateHash()) {
                return false;
            }

            // 检查是否正确指向前一个区块
            if (currentBlock.previousHash !== previousBlock.hash) {
                return false;
            }
        }
        return true;
    }
}

// 测试
const myChain = new SimpleBlockchain();
myChain.addBlock(['Alice -> Bob: 10 ETH']);
myChain.addBlock(['Bob -> Charlie: 5 ETH']);

console.log('链是否有效:', myChain.isChainValid()); // true

// 尝试篡改
myChain.chain[1].transactions = ['Alice -> Bob: 1 ETH']; // 篡改交易
console.log('篡改后链是否有效:', myChain.isChainValid()); // false
```

---

## 新手最常踩的 3 个坑

### 坑 1：以为交易是即时确认的

**错误认知**：发起交易后，立刻就完成了

**真相**：
- 交易发出后先进入「待处理池」(mempool)
- 需要等待被打包进区块（以太坊约12秒一个区块）
- 为了安全，通常需要等待多个区块确认（交易所一般要求12-35个确认）

**建议**：
- 小额交易：1-2个区块确认即可
- 大额交易：等待更多确认（12个以上）
- 理解「最终确定性」的概念

### 坑 2：以为区块链能存储大量数据

**错误认知**：可以把文件、图片存在区块链上

**真相**：
- 链上存储极其昂贵（以太坊约 20,000 Gas / 32字节）
- 存储 1MB 数据可能花费数千美元的 Gas
- NFT 图片通常存在 IPFS，链上只存引用

**建议**：
- 链上只存必要的状态和哈希
- 大文件用 IPFS、Arweave 等去中心化存储
- 理解链上/链下数据的取舍

### 坑 3：混淆公链、私链、联盟链

**三者区别**：

| 类型 | 谁能参与 | 谁能记账 | 例子 |
|------|---------|---------|------|
| 公链 | 任何人 | 任何人（满足条件） | 以太坊、比特币 |
| 联盟链 | 授权节点 | 授权节点 | Hyperledger |
| 私链 | 单一组织 | 单一组织 | 内部测试链 |

**建议**：
- 需要去中心化和抗审查 -> 公链
- 企业间协作但需要隐私 -> 联盟链
- 学习和测试 -> 私链或测试网

---

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────────┐
│                    以太坊交易生命周期                                │
└─────────────────────────────────────────────────────────────────────┘

 [你在这里学习的内容]
        ↓
┌──────────────────────────────────────────────────────────────────────┐
│  整体架构：区块链是如何工作的                                          │
│  ├─ 区块结构：区块头 + 交易列表                                       │
│  ├─ 链式结构：通过哈希链接形成不可篡改的链                              │
│  ├─ 状态管理：所有账户余额、合约状态的全局快照                          │
│  └─ 共识机制：网络如何对新区块达成一致（详见共识机制章节）               │
└──────────────────────────────────────────────────────────────────────┘
        ↓
  接下来学习：以太坊账户 -> 理解地址和私钥
```

---

## 自测题

### 基础理解

1. **为什么说区块链是「不可篡改」的？篡改一个历史交易需要付出什么代价？**

<details>
<summary>参考答案</summary>

每个区块包含前一个区块的哈希。如果篡改某个区块的数据，该区块的哈希会改变，导致后续所有区块的「前一区块哈希」字段都变得无效。

要让篡改生效，必须：
1. 重新计算被篡改区块的哈希
2. 重新计算之后所有区块的哈希
3. 在 PoS 系统中，需要控制大量质押的 ETH，经济上不可行
</details>

2. **区块链和传统数据库的核心区别是什么？什么场景应该用区块链，什么场景用传统数据库更好？**

<details>
<summary>参考答案</summary>

核心区别：
- 数据库：中心化控制，可增删改查，高效但依赖管理员
- 区块链：去中心化，只能追加，低效但无需信任第三方

适合区块链：
- 多方协作但互不信任
- 需要透明和可审计
- 需要抗审查

适合数据库：
- 有可信的中心方
- 需要高性能
- 数据需要修改/删除
- 隐私敏感
</details>

3. **「区块链是匿名的」这个说法对吗？为什么？**

<details>
<summary>参考答案</summary>

不完全对，更准确的说法是「假名」(Pseudonymous)。

- 地址不绑定真实身份，这点像匿名
- 但所有交易完全公开，可以追踪
- 一旦某个地址和真实身份关联（如通过交易所KYC），历史交易都可追溯
- 链上分析公司（如 Chainalysis）可以通过交易模式识别身份
</details>

### 进阶思考

4. **如果你要设计一个投票系统，会选择用区块链吗？考虑其利弊。**

<details>
<summary>参考答案</summary>

需要权衡：

使用区块链的好处：
- 投票记录不可篡改
- 公开透明，可审计
- 抗审查，难以操纵

问题和挑战：
- 隐私问题：公链上投票公开，如何保证投票隐私？
- 身份验证：如何确保一人一票？（链上很难验证链下身份）
- 用户体验：普通用户使用门槛高

可能的方案：
- 使用零知识证明保护隐私
- 结合链下身份验证 + 链上投票记录
- 或者使用联盟链/私链
</details>
