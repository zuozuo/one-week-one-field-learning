# HTTPS握手全流程 - 单点穿透演练

> 这是密码学学习的综合案例。通过跟踪一次完整的HTTPS连接，我们将把前面学的所有概念串联起来。

## 案例背景

**场景：** 你在浏览器地址栏输入 `https://www.taobao.com`，按下回车。

**问题：** 从你按下回车到页面显示，密码学是如何保护这次通信的？

**涉及的技术：**
- 数字证书（身份验证）
- 非对称加密 / ECDH（密钥交换）
- 对称加密 AES（数据加密）
- 哈希函数 SHA-256（完整性校验）
- 数字签名（证书签名）

---

## 流程全景图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        HTTPS 握手完整流程 (TLS 1.3)                          │
└─────────────────────────────────────────────────────────────────────────────┘

    浏览器 (客户端)                                      服务器 (淘宝)
         │                                                    │
         │  ============== 第一阶段：打招呼 ==============      │
         │                                                    │
    ┌────┴────┐                                               │
    │ 生成临时 │                                               │
    │ ECDH密钥 │                                               │
    └────┬────┘                                               │
         │                                                    │
         │───────────── ClientHello ─────────────────────────>│
         │  • 支持的TLS版本                                    │
         │  • 支持的加密套件列表                               │
         │  • 客户端随机数                                     │
         │  • 客户端ECDH公钥                                   │
         │                                                    │
         │                                               ┌────┴────┐
         │                                               │ 生成临时 │
         │                                               │ ECDH密钥 │
         │                                               └────┬────┘
         │                                                    │
         │<──────────── ServerHello ──────────────────────────│
         │  • 选定的TLS版本                                    │
         │  • 选定的加密套件                                   │
         │  • 服务器随机数                                     │
         │  • 服务器ECDH公钥                                   │
         │                                                    │
         │<──────────── Certificate ──────────────────────────│
         │  • 服务器证书                                       │
         │  • 证书链（中间CA证书）                             │
         │                                                    │
         │<──────────── CertificateVerify ────────────────────│
         │  • 握手消息的签名（证明拥有私钥）                   │
         │                                                    │
         │<──────────── Finished ─────────────────────────────│
         │  • 服务器握手完成                                   │
         │                                                    │
         │  ============== 第二阶段：验证身份 ==============    │
         │                                                    │
    ┌────┴────┐                                               │
    │ 验证证书 │                                               │
    │ • 签名链 │                                               │
    │ • 有效期 │                                               │
    │ • 吊销  │                                               │
    └────┬────┘                                               │
         │                                                    │
         │  ============== 第三阶段：计算密钥 ==============    │
         │                                                    │
    ┌────┴────┐                                          ┌────┴────┐
    │计算共享  │                                          │计算共享  │
    │秘密(ECDH)│                                          │秘密(ECDH)│
    └────┬────┘                                          └────┬────┘
         │                                                    │
    ┌────┴────┐                                          ┌────┴────┐
    │派生会话  │                                          │派生会话  │
    │密钥(HKDF)│                                          │密钥(HKDF)│
    └────┬────┘                                          └────┬────┘
         │                                                    │
         │───────────── Finished ─────────────────────────────>│
         │  • 客户端握手完成                                   │
         │                                                    │
         │  ============== 第四阶段：加密通信 ==============    │
         │                                                    │
         │◀═══════════ 使用AES-GCM加密 ═══════════════════════▶│
         │             HTTP请求/响应                           │
         │             (对称加密，高速)                        │
         │                                                    │
```

---

## 流程演练

### 节点 1：ClientHello（客户端打招呼）

#### 输入
- 用户请求访问 https://www.taobao.com
- 浏览器的能力配置（支持哪些加密算法）

#### 加工
1. 生成32字节的客户端随机数
2. 生成临时ECDH密钥对
3. 准备支持的加密套件列表

#### 输出
```
ClientHello:
  Version: TLS 1.3
  Random: 7a8f2b3c... (32字节随机数)
  Cipher Suites:
    - TLS_AES_256_GCM_SHA384
    - TLS_AES_128_GCM_SHA256
    - TLS_CHACHA20_POLY1305_SHA256
  Supported Groups:
    - x25519
    - secp256r1
  Key Share:
    - x25519: 3a7b2c... (客户端ECDH公钥)
```

#### 常见失败原因
1. **网络不通**：DNS解析失败或服务器不可达
2. **端口错误**：HTTPS默认443端口被防火墙阻断
3. **协议版本不兼容**：客户端和服务器支持的TLS版本没有交集

#### 用到的密码学技术
- **随机数生成**：必须是密码学安全的随机数
- **ECDH**：临时密钥对用于密钥交换

---

### 节点 2：ServerHello + Certificate（服务器响应）

#### 输入
- ClientHello 消息
- 服务器配置和证书

#### 加工
1. 从客户端列表中选择最优的加密套件
2. 生成服务器随机数
3. 生成临时ECDH密钥对
4. 准备证书链

#### 输出
```
ServerHello:
  Version: TLS 1.3
  Random: 9c4d5e... (32字节随机数)
  Cipher Suite: TLS_AES_256_GCM_SHA384
  Key Share:
    - x25519: 5e6f7a... (服务器ECDH公钥)

Certificate:
  服务器证书:
    Subject: CN=www.taobao.com
    Issuer: DigiCert SHA2 Extended Validation Server CA
    Public Key: RSA 2048位
    Valid: 2024-01-01 到 2025-01-01
    Signature: SHA256withRSA

  中间CA证书:
    Subject: DigiCert SHA2 Extended Validation Server CA
    Issuer: DigiCert High Assurance EV Root CA
    ...

CertificateVerify:
  Signature: 对整个握手消息的签名
  Algorithm: RSA-PSS-SHA256
```

#### 常见失败原因
1. **证书过期**：服务器证书超过有效期
2. **证书域名不匹配**：证书上的域名和访问的域名不一致
3. **加密套件不兼容**：服务器不支持客户端的任何加密套件

#### 用到的密码学技术
- **ECDH**：服务器也生成临时密钥对
- **数字证书**：证明服务器身份
- **数字签名**：CertificateVerify 证明服务器拥有证书私钥

---

### 节点 3：证书验证（客户端验证服务器身份）

#### 输入
- 服务器证书和证书链
- 浏览器内置的根CA列表

#### 加工

```
┌─────────────────────────────────────────────────────────────────┐
│                    证书验证详细步骤                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Step 1: 检查证书是否过期                                       │
│  ─────────────────────────────────────                         │
│  当前时间: 2024-06-15                                           │
│  证书有效期: 2024-01-01 ~ 2025-01-01                           │
│  结果: ✅ 在有效期内                                            │
│                                                                 │
│  Step 2: 检查域名匹配                                           │
│  ─────────────────────────                                     │
│  请求域名: www.taobao.com                                       │
│  证书域名: CN=www.taobao.com, SAN=*.taobao.com                 │
│  结果: ✅ 匹配                                                  │
│                                                                 │
│  Step 3: 验证签名链                                             │
│  ──────────────────                                            │
│                                                                 │
│  服务器证书                                                      │
│       │                                                         │
│       │ 用中间CA公钥验证签名                                    │
│       ▼                                                         │
│  中间CA证书                                                      │
│       │                                                         │
│       │ 用根CA公钥验证签名                                      │
│       ▼                                                         │
│  根CA证书 (内置信任)                                            │
│                                                                 │
│  结果: ✅ 签名链有效                                            │
│                                                                 │
│  Step 4: 检查吊销状态 (OCSP)                                    │
│  ────────────────────────                                      │
│  查询OCSP服务器...                                              │
│  结果: ✅ 证书未被吊销                                          │
│                                                                 │
│  Step 5: 验证 CertificateVerify                                │
│  ─────────────────────────────                                 │
│  用证书中的公钥验证握手消息签名                                  │
│  结果: ✅ 服务器确实拥有私钥                                    │
│                                                                 │
│  最终结果: 证书验证通过 ✅                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 输出
- 验证通过：继续握手
- 验证失败：显示警告页面，让用户选择是否继续

#### 常见失败原因
1. **证书链不完整**：服务器没有发送中间CA证书
2. **根CA不受信任**：自签名证书或未知CA
3. **证书被吊销**：私钥泄露后被CA吊销

#### 用到的密码学技术
- **数字签名验证**：验证证书链的每一级签名
- **哈希函数**：计算证书指纹用于比对

---

### 节点 4：密钥计算（ECDH密钥交换）

#### 输入
- 客户端私钥 + 服务器公钥
- 服务器私钥 + 客户端公钥
- 客户端随机数 + 服务器随机数

#### 加工

```
┌─────────────────────────────────────────────────────────────────┐
│                    密钥派生过程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  客户端计算:                     服务器计算:                     │
│                                                                 │
│  shared_secret =                shared_secret =                 │
│    ECDH(客户端私钥,              ECDH(服务器私钥,                │
│         服务器公钥)                   客户端公钥)               │
│         │                              │                        │
│         └──────────────┬───────────────┘                        │
│                        │                                        │
│                        ▼                                        │
│               shared_secret (相同！)                            │
│                        │                                        │
│                        ▼                                        │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    HKDF 密钥派生                          │  │
│  │                                                          │  │
│  │  输入:                                                   │  │
│  │  - shared_secret                                         │  │
│  │  - 客户端随机数                                          │  │
│  │  - 服务器随机数                                          │  │
│  │  - 握手消息哈希                                          │  │
│  │                                                          │  │
│  │  输出 (多个密钥):                                        │  │
│  │  - client_write_key (客户端→服务器加密)                  │  │
│  │  - server_write_key (服务器→客户端加密)                  │  │
│  │  - client_write_iv  (客户端加密IV)                       │  │
│  │  - server_write_iv  (服务器加密IV)                       │  │
│  │                                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 输出
- 四个密钥：客户端加密密钥、服务器加密密钥、两个IV
- 这些密钥从不在网络上传输！

#### 常见失败原因
1. **ECDH计算错误**：实现bug导致双方计算结果不同
2. **参数被篡改**：中间人修改了公钥（但有签名保护）

#### 用到的密码学技术
- **ECDH**：计算共享秘密
- **HKDF**：从共享秘密派生多个密钥
- **哈希函数**：计算握手消息哈希作为派生输入

---

### 节点 5：握手完成（Finished消息）

#### 输入
- 派生的会话密钥
- 整个握手过程的消息

#### 加工
1. 计算整个握手消息的哈希
2. 用派生的密钥计算验证数据
3. 双方交换Finished消息确认密钥一致

#### 输出
```
Client Finished:
  verify_data = HMAC(finished_key, Hash(所有握手消息))

Server Finished:
  verify_data = HMAC(finished_key, Hash(所有握手消息))
```

#### 验证
- 如果双方计算的verify_data相同，说明：
  1. 密钥计算正确
  2. 握手消息没被篡改
  3. 可以开始加密通信

#### 常见失败原因
1. **密钥不匹配**：某一方密钥计算错误
2. **消息被篡改**：中间人修改了握手消息

#### 用到的密码学技术
- **HMAC**：消息认证码
- **哈希函数**：计算握手消息摘要

---

### 节点 6：加密通信（应用数据传输）

#### 输入
- 会话密钥（AES-GCM密钥 + IV）
- HTTP请求/响应数据

#### 加工

```
┌─────────────────────────────────────────────────────────────────┐
│                    数据加密过程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  发送HTTP请求:                                                   │
│                                                                 │
│  GET / HTTP/1.1                                                 │
│  Host: www.taobao.com                                           │
│  Cookie: session=abc123                                         │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              AES-256-GCM 加密                            │   │
│  │                                                          │   │
│  │  输入:                                                   │   │
│  │  - 明文: HTTP请求                                        │   │
│  │  - 密钥: client_write_key                               │   │
│  │  - IV: client_write_iv + 序列号                         │   │
│  │  - 附加数据: 记录头                                      │   │
│  │                                                          │   │
│  │  输出:                                                   │   │
│  │  - 密文                                                  │   │
│  │  - 认证标签 (16字节)                                     │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│         │                                                       │
│         ▼                                                       │
│  TLS Record:                                                    │
│  [记录头][加密的HTTP请求][认证标签]                              │
│         │                                                       │
│         ▼                                                       │
│      发送到服务器                                                │
│                                                                 │
│  ───────────────────────────────────────────────────────────── │
│                                                                 │
│  服务器解密:                                                     │
│                                                                 │
│  1. 用 server_write_key 解密                                   │
│  2. 验证认证标签 → 确保数据没被篡改                             │
│  3. 得到原始HTTP请求                                            │
│  4. 处理请求，返回响应（同样加密）                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 输出
- 加密的HTTP请求/响应
- 认证标签（保证完整性）

#### 常见失败原因
1. **认证标签验证失败**：数据被篡改
2. **序列号不同步**：实现bug
3. **连接中断**：网络问题

#### 用到的密码学技术
- **AES-GCM**：对称加密 + 认证（AEAD）
- 每条消息用不同的IV（通过序列号保证）

---

## 为什么这样设计？

### Q1: 为什么用非对称加密交换密钥，而不是直接用非对称加密通信？

```
性能对比：

RSA-2048 加密:     ~1000 次/秒
AES-256 加密:      ~1,000,000 次/秒

差距 1000 倍！

所以：
- 用慢的非对称加密传一个小密钥（几百字节）
- 用快的对称加密传实际数据（可能是GB级）
```

### Q2: 为什么需要证书？DH不是已经能安全交换密钥了吗？

```
没有证书的DH（中间人攻击）：

浏览器 ←──→ 攻击者 ←──→ 淘宝
        ↑         ↑
      密钥K1    密钥K2

攻击者可以：
1. 和浏览器协商密钥K1
2. 和淘宝协商密钥K2
3. 解密浏览器消息，查看/修改，再加密发给淘宝
4. 双方都不知道中间有人！

有证书后：
- 淘宝的公钥有CA签名
- 攻击者无法伪造CA签名
- 浏览器能发现公钥不对
```

### Q3: 如果去掉证书会有什么风险？

```
风险场景：

1. 咖啡厅WiFi钓鱼
   - 攻击者架设同名WiFi
   - 拦截所有HTTPS流量
   - 用自己的证书冒充任何网站
   - 窃取密码、银行卡信息

2. DNS劫持
   - 把 taobao.com 解析到攻击者服务器
   - 没有证书验证，用户无法发现

3. BGP劫持
   - 更底层的网络攻击
   - 让流量经过攻击者控制的路由

证书是防止这些攻击的最后一道防线！
```

---

## 常见坑点提醒

### 1. TLS版本问题
- TLS 1.0/1.1 已被弃用，存在安全漏洞
- 应该使用 TLS 1.2 或 1.3
- TLS 1.3 更简洁（只需1个RTT）

### 2. 证书配置问题
- 一定要配置完整的证书链
- 定期更新证书（提前30天）
- 私钥权限要严格控制

### 3. 加密套件选择
```
推荐（TLS 1.3）：
✅ TLS_AES_256_GCM_SHA384
✅ TLS_CHACHA20_POLY1305_SHA256
✅ TLS_AES_128_GCM_SHA256

不推荐：
❌ 任何包含 RC4 的套件
❌ 任何包含 3DES 的套件
❌ 任何包含 MD5 的套件
❌ 任何不带 AEAD 的套件
```

### 4. 前向保密
- 确保使用 ECDHE 而不是 RSA 密钥交换
- TLS 1.3 强制前向保密

---

## 动手实验

### 实验1：查看真实的TLS握手

```bash
# 使用 openssl 查看握手过程
openssl s_client -connect www.taobao.com:443 -state -debug

# 查看协商的加密套件
openssl s_client -connect www.taobao.com:443 < /dev/null 2>/dev/null | grep "Cipher"

# 查看证书链
openssl s_client -connect www.taobao.com:443 -showcerts < /dev/null
```

### 实验2：用 Wireshark 抓包

1. 打开 Wireshark，选择网络接口
2. 过滤器输入：`tls`
3. 浏览器访问 https://www.taobao.com
4. 观察 TLS 握手包：
   - ClientHello
   - ServerHello
   - Certificate
   - 等等...

### 实验3：Python模拟TLS连接

```python
import ssl
import socket

hostname = 'www.taobao.com'
port = 443

# 创建SSL上下文
context = ssl.create_default_context()

# 连接并获取信息
with socket.create_connection((hostname, port)) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print(f"TLS版本: {ssock.version()}")
        print(f"加密套件: {ssock.cipher()}")
        print(f"证书主体: {ssock.getpeercert()['subject']}")
```

---

## 复盘

### 我学到的 3 件事

1. **混合加密是必须的**：非对称加密解决密钥分发，对称加密解决效率问题。两者缺一不可。

2. **证书是信任的基石**：没有证书，密钥交换形同虚设。CA体系虽然有缺陷，但目前是最实用的解决方案。

3. **安全是一个系统**：单独一个技术（加密、签名、哈希）都不够，必须组合使用才能构建安全的系统。

### 仍不确定的 3 件事

1. **TLS 1.3的0-RTT模式**：如何在保证前向保密的同时支持0-RTT？有什么安全取舍？

2. **证书透明度(CT)**：如何防止CA被入侵后签发假证书？CT日志是如何工作的？

3. **后量子密码学**：量子计算机能破解ECDH吗？HTTPS如何应对量子威胁？

### 下一步要查的 3 个点

1. **HSTS**：如何防止SSL剥离攻击？
2. **证书固定(Pinning)**：如何进一步增强证书验证？
3. **mTLS**：双向TLS认证是如何工作的？

---

## 终极检验

现在，你应该能够：

- [ ] 向朋友解释"为什么浏览器地址栏有个小锁图标"
- [ ] 说明HTTPS使用了哪些密码学技术，分别解决什么问题
- [ ] 解释为什么不能只用非对称加密
- [ ] 解释证书的作用以及如果去掉证书会有什么风险
- [ ] 描述一次完整的TLS握手流程

**恭喜！如果你能做到以上这些，说明你已经掌握了密码学的核心知识！** 🎉

---

> 记住：密码学的目标不是让系统"绝对安全"（那是不可能的），而是让攻击的成本远远超过攻击的收益。
