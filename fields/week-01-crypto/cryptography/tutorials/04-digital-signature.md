# 数字签名（Digital Signature）

## 一句话大白话

**数字签名就是电子世界的"签字画押"——证明这消息确实是我发的，而且没被改过。**

```
现实世界：合同 + 你的签名 → 证明是你签的
数字世界：消息 + 数字签名 → 证明是你发的

区别：数字签名不仅证明身份，还能证明内容没被篡改！
```

## 它解决什么问题

数字签名同时解决两个问题：

### 1. 认证性（Authentication）
证明消息确实来自声称的发送者

### 2. 完整性（Integrity）
证明消息在传输过程中没被修改

### 3. 不可否认性（Non-repudiation）
发送者不能否认自己发过这个消息

**使用场景：**

| 场景 | 说明 |
|------|------|
| 软件发布 | 证明软件确实来自官方（如苹果App Store） |
| 电子合同 | 有法律效力的电子签名 |
| 数字货币 | 比特币交易用签名证明是账户主人发起的 |
| 代码签名 | 证明代码没被篡改 |
| SSL证书 | CA用签名证明证书的真实性 |
| JWT令牌 | 服务端签名，客户端无法伪造 |

**生活类比：**
你写了一封重要的信，除了签名，还在信封口滴上火漆并盖上你的印章。收件人通过印章确认是你发的（认证），通过火漆确认信没被拆开过（完整性）。

## 数字签名的原理

```
┌─────────────────────────────────────────────────────────────────┐
│                      数字签名流程                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【签名过程】发送方（Alice）                                      │
│                                                                 │
│  原始消息                                                        │
│      │                                                          │
│      ▼                                                          │
│  ┌────────────┐                                                 │
│  │  哈希函数  │  → 消息摘要（固定长度）                          │
│  └────────────┘                                                 │
│                    │                                            │
│                    ▼                                            │
│              ┌────────────┐                                     │
│              │ 私钥加密   │  → 数字签名                          │
│              └────────────┘                                     │
│                                                                 │
│  发送：原始消息 + 数字签名                                       │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【验证过程】接收方（Bob）                                        │
│                                                                 │
│  收到：原始消息 + 数字签名                                       │
│                                                                 │
│  路径1：                    路径2：                              │
│  原始消息                   数字签名                             │
│      │                         │                                │
│      ▼                         ▼                                │
│  ┌────────────┐          ┌────────────┐                        │
│  │  哈希函数  │          │ 公钥解密   │                        │
│  └────────────┘          └────────────┘                        │
│      │                         │                                │
│      ▼                         ▼                                │
│   摘要A                     摘要B                                │
│      │                         │                                │
│      └───────────┬─────────────┘                                │
│                  ▼                                              │
│           摘要A == 摘要B ?                                       │
│                  │                                              │
│         ┌───────┴───────┐                                       │
│         ▼               ▼                                       │
│        是              否                                        │
│         │               │                                       │
│    签名有效 ✅      签名无效 ❌                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**为什么要先哈希？**
1. 非对称加密很慢，直接签名大文件太耗时
2. 消息可能很长，但哈希值是固定长度（如256位）
3. 签名长度固定，方便处理

## 什么时候用 / 什么时候别用

### ✅ 适合用的场景

| 场景 | 说明 |
|------|------|
| 需要验证来源 | 确认消息确实是某人/某系统发的 |
| 需要防篡改 | 检测消息是否被修改 |
| 需要不可否认 | 发送者不能抵赖 |
| 公开场景 | 任何人都能验证，但只有私钥持有者能签名 |

### ❌ 不适合用的场景

| 场景 | 原因 |
|------|------|
| 保护消息内容 | 签名不提供机密性，消息仍是明文！ |
| 需要否认能力 | 有时候需要"可否认加密" |
| 大量签名操作 | 非对称操作较慢，考虑批量签名 |

## 它不是什么（常见混淆）

| 误解 | 真相 |
|------|------|
| "签名能加密消息" | ❌ 签名不加密！签名后消息仍是明文可读的 |
| "签名用公钥" | ❌ 签名用私钥，验证用公钥 |
| "加密和签名是一回事" | ❌ 方向相反！加密用公钥，签名用私钥 |
| "有签名就安全了" | ❌ 签名只保证来源和完整性，不保证机密性 |

## 签名 vs 加密 对比

```
┌───────────────────────────────────────────────────────────────┐
│                    加密 vs 签名                                │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  【加密】目的：保密                                            │
│                                                               │
│  发送方用 → 接收方公钥加密                                     │
│  接收方用 → 自己私钥解密                                       │
│                                                               │
│  效果：只有接收方能看到内容                                     │
│                                                               │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  【签名】目的：证明身份                                        │
│                                                               │
│  发送方用 → 自己私钥签名                                       │
│  接收方用 → 发送方公钥验证                                     │
│                                                               │
│  效果：任何人都能验证是发送方签的                               │
│                                                               │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  【既要加密又要签名】                                          │
│                                                               │
│  先签名，再加密！                                              │
│  1. 用自己私钥签名                                            │
│  2. 用对方公钥加密（签名+消息）                                │
│                                                               │
│  效果：保密 + 认证 + 完整性                                    │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

## 主要算法对比

| 算法 | 基于 | 签名长度 | 状态 | 说明 |
|------|------|----------|------|------|
| RSA签名 | RSA | 2048位+ | ✅ 可用 | 传统算法，兼容性好 |
| DSA | 离散对数 | 可变 | ⚠️ 不推荐 | 老旧，正在被淘汰 |
| ECDSA | 椭圆曲线 | 256-512位 | ✅ 推荐 | 比特币使用 |
| **Ed25519** | 椭圆曲线 | 512位 | ✅ 强烈推荐 | 快速、安全、简单 |

**选择建议：新项目用 Ed25519，需要兼容性用 ECDSA 或 RSA。**

## 最小例子

### Python 示例：Ed25519 签名

```python
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from cryptography.hazmat.primitives import serialization

# 1. 生成密钥对
private_key = Ed25519PrivateKey.generate()
public_key = private_key.public_key()

# 2. 签名
message = b"Transfer 100 BTC to Alice"
signature = private_key.sign(message)

print(f"消息: {message}")
print(f"签名: {signature.hex()[:32]}...")
print(f"签名长度: {len(signature)} 字节")

# 3. 验证（成功）
try:
    public_key.verify(signature, message)
    print("签名验证成功 ✅")
except:
    print("签名验证失败 ❌")

# 4. 篡改消息后验证（失败）
tampered_message = b"Transfer 10000 BTC to Alice"  # 金额被改了！
try:
    public_key.verify(signature, tampered_message)
    print("签名验证成功")
except:
    print("篡改后验证失败 ✅ 这是预期的")
```

### Python 示例：RSA 签名

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes

# 1. 生成RSA密钥对
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)
public_key = private_key.public_key()

# 2. 签名（先哈希再签名）
message = b"This is an important document"
signature = private_key.sign(
    message,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
)

print(f"RSA签名长度: {len(signature)} 字节")  # 256字节

# 3. 验证
try:
    public_key.verify(
        signature,
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    print("RSA签名验证成功 ✅")
except:
    print("RSA签名验证失败 ❌")
```

### 命令行示例（OpenSSL）

```bash
# 生成密钥对
openssl genpkey -algorithm Ed25519 -out private.pem
openssl pkey -in private.pem -pubout -out public.pem

# 签名文件
openssl pkeyutl -sign -inkey private.pem -in document.txt -out signature.bin

# 验证签名
openssl pkeyutl -verify -pubin -inkey public.pem -in document.txt -sigfile signature.bin
# 输出: Signature Verified Successfully
```

## 新手最常踩的 3 个坑

### 坑1：以为签名能保密

```
❌ 错误理解
message = "密码是123456"
signature = sign(message, private_key)
send(message, signature)  # 消息是明文！任何人都能看到！

✅ 正确理解
# 签名只保证来源和完整性，不保证机密性
# 如果要保密，需要额外加密
ciphertext = encrypt(message + signature, recipient_public_key)
send(ciphertext)
```

### 坑2：私钥泄露后继续使用

```
❌ 危险操作
# 私钥泄露了，但你继续用这个私钥签名
signature = sign(message, compromised_private_key)
# 攻击者可以用泄露的私钥伪造任何签名！

✅ 正确做法
# 1. 立即吊销相关证书
# 2. 生成新的密钥对
# 3. 公告旧密钥已失效
# 4. 重新签发证书
```

### 坑3：不验证消息完整后就信任

```
❌ 错误做法
def process_request(message, signature, public_key):
    # 直接处理消息，没验证签名！
    execute(message)

✅ 正确做法
def process_request(message, signature, public_key):
    # 先验证签名
    if not verify(signature, message, public_key):
        raise SecurityError("Invalid signature!")
    # 验证通过后才处理
    execute(message)
```

## 真实案例：比特币交易签名

```
┌─────────────────────────────────────────────────────────────────┐
│                    比特币交易签名流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Alice想转1 BTC给Bob                                            │
│                                                                 │
│  ┌─────────────────────────────────────────────┐               │
│  │ 交易数据：                                   │               │
│  │ - 从: Alice地址                             │               │
│  │ - 到: Bob地址                               │               │
│  │ - 金额: 1 BTC                               │               │
│  └─────────────────────────────────────────────┘               │
│                    │                                            │
│                    ▼                                            │
│  ┌─────────────────────────────────────────────┐               │
│  │ Alice用私钥签名                              │               │
│  │ (证明是账户主人发起的)                       │               │
│  └─────────────────────────────────────────────┘               │
│                    │                                            │
│                    ▼                                            │
│  ┌─────────────────────────────────────────────┐               │
│  │ 广播到比特币网络                             │               │
│  │ 交易数据 + 签名                              │               │
│  └─────────────────────────────────────────────┘               │
│                    │                                            │
│                    ▼                                            │
│  ┌─────────────────────────────────────────────┐               │
│  │ 所有节点用Alice的公钥验证：                  │               │
│  │ - 签名是否有效 ✓                            │               │
│  │ - 确实是Alice授权的 ✓                       │               │
│  │ - 金额没被篡改 ✓                            │               │
│  └─────────────────────────────────────────────┘               │
│                    │                                            │
│                    ▼                                            │
│                交易确认 ✅                                       │
│                                                                 │
│  【安全保证】                                                    │
│  - 没有私钥，无法伪造Alice的签名                                 │
│  - 任何人都能验证交易合法性                                      │
│  - 改动任何一个字节，签名就会失效                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     安全通信流程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ████████████                                                   │
│  │ 身份验证 │  ← 你在这里！                                     │
│  ████████████                                                   │
│       │                                                         │
│       ├── 数字证书（包含公钥 + CA签名）                          │
│       │                                                         │
│       └── 验证签名 → 确认身份                                    │
│              │                                                  │
│              ▼                                                  │
│         密钥交换 → 对称加密通信                                  │
│                                                                 │
│  数字签名在HTTPS中的作用：                                       │
│  1. CA签发证书时对证书签名                                       │
│  2. 客户端验证证书签名确认身份                                   │
│  3. 某些握手步骤需要签名防篡改                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**上游依赖：** 哈希函数（签名前先哈希）、非对称加密（提供密钥对）
**下游消费：** 数字证书（用签名保证证书真实性）

## 自测题

### 题目1：Alice用自己的私钥"加密"了一段消息，这叫什么？谁能"解密"？

<details>
<summary>点击查看答案</summary>

这叫**签名**，不是加密。

"解密"应该叫**验证**，任何拥有Alice公钥的人都能验证。

这就是签名的目的：证明消息来自Alice。
- 如果Alice想保密，应该用**对方的公钥**加密
- 用自己私钥操作 = 签名（任何人可验证）
- 用对方公钥操作 = 加密（只有对方能解）

</details>

### 题目2：Bob收到一条消息和签名，验证通过了。能说明什么？不能说明什么？

<details>
<summary>点击查看答案</summary>

**能说明：**
1. 消息确实来自签名者（拥有私钥的人）
2. 消息没有被篡改
3. 签名者不能否认发送过这条消息

**不能说明：**
1. 消息内容是保密的（签名不加密，消息是明文）
2. 签名者的身份是真实的（可能私钥被盗，或者Bob不知道公钥对应谁）
3. 消息是最新的（可能是重放攻击，之前的签名消息被重复发送）

这就是为什么实际系统中签名要配合证书（确认身份）和时间戳（防重放）。

</details>

### 题目3：为什么数字签名要先对消息做哈希，而不是直接签名？

<details>
<summary>点击查看答案</summary>

三个原因：

1. **效率**：非对称加密很慢，大文件直接签名太耗时。哈希后只需签名固定长度的摘要（如32字节）。

2. **统一长度**：签名算法对输入长度有限制。哈希后长度固定，无论原消息多大。

3. **安全性**：某些签名方案直接签名可能有安全问题，先哈希更安全。

流程：
```
100MB文件 → 哈希 → 32字节摘要 → 签名 → 64字节签名
                              很快！
```

</details>

---

## 总结

| 要点 | 内容 |
|------|------|
| 核心概念 | 私钥签名，公钥验证；证明来源+完整性 |
| 推荐算法 | Ed25519（新项目）、ECDSA（兼容性）|
| 关键原则 | 签名不加密！私钥必须保密 |
| 工作流程 | 消息→哈希→私钥签名→发送(消息+签名)→公钥验证 |

**下一步：** 学习[密钥交换](05-key-exchange.md)，了解陌生人如何安全协商密钥！
