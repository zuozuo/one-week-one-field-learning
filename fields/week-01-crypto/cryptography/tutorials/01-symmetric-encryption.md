# 对称加密（Symmetric Encryption）

## 一句话大白话

**加密和解密用同一把钥匙，就像你家的门锁——用同一把钥匙锁门和开门。**

```
明文 + 密钥 → [加密] → 密文
密文 + 密钥 → [解密] → 明文
         ↑
      同一把钥匙！
```

## 它解决什么问题

对称加密解决的是**机密性**问题：让信息在传输过程中不被偷看。

**使用场景：**
- 加密存储的文件（比如压缩包加密）
- 加密数据库中的敏感字段
- HTTPS建立连接后的实际数据传输
- 即时通讯的消息加密

**生活类比：**
想象你和朋友约定了一个暗号本，A=1，B=2... 你们用这个本子把信变成数字，对方收到后再用同一个本子还原。这就是对称加密——你们共用一个"暗号本"（密钥）。

## 什么时候用 / 什么时候别用

### ✅ 适合用的场景

| 场景 | 说明 |
|------|------|
| 双方已经有共享密钥 | 比如通过线下交换、或通过其他安全方式协商好了 |
| 需要加密大量数据 | 对称加密速度快，适合加密文件、视频流等 |
| 性能要求高 | 比非对称加密快1000倍以上 |
| 本地数据加密 | 比如加密自己硬盘上的文件 |

### ❌ 不适合用的场景

| 场景 | 原因 |
|------|------|
| 第一次通信的两个陌生人 | 密钥怎么传？传密钥的过程就不安全 |
| 需要身份认证 | 对称加密只能加密，不能证明"是谁发的" |
| 一对多通信 | 每对用户都要不同密钥，管理噩梦 |

## 它不是什么（常见混淆）

| 误解 | 真相 |
|------|------|
| "对称加密能防篡改" | ❌ 不能！对称加密只保证机密性，不保证完整性。需要配合HMAC使用 |
| "AES是一种加密模式" | ❌ AES是算法，ECB/CBC/GCM才是模式 |
| "加密后数据就安全了" | ❌ 密钥泄露了，加密就白做了 |
| "用两次就更安全" | ❌ 双重DES被中间相遇攻击破解，反而不安全 |

## 主要算法对比

| 算法 | 密钥长度 | 状态 | 说明 |
|------|----------|------|------|
| DES | 56位 | ❌ 已淘汰 | 1977年，已被暴力破解 |
| 3DES | 168位 | ⚠️ 不推荐 | DES的补丁，太慢 |
| **AES** | 128/192/256位 | ✅ 推荐 | 目前标准，用它就对了 |
| ChaCha20 | 256位 | ✅ 推荐 | 移动设备友好，TLS 1.3采用 |

**记住：现在就用 AES-256，别纠结了。**

## 加密模式（重要！）

算法确定后，还要选择"模式"。这是新手最容易踩坑的地方！

```
┌────────────────────────────────────────────────────────────┐
│                    加密模式对比                             │
├──────────┬────────────────────────────────────────────────┤
│          │                                                │
│   ECB    │  ████  ████  ████   相同明文→相同密文          │
│  (别用)  │  ████  ████  ████   能看出图案！               │
│          │                                                │
├──────────┼────────────────────────────────────────────────┤
│          │                                                │
│   CBC    │  ▓▒░█  █▓▒░  ░▓▒█   每块都不同                │
│  (可以)  │  需要IV，串行加密                              │
│          │                                                │
├──────────┼────────────────────────────────────────────────┤
│          │                                                │
│   GCM    │  ▓▒░█  █▓▒░  ░▓▒█  + 完整性校验               │
│  (推荐)  │  加密的同时验证数据没被改                      │
│          │                                                │
└──────────┴────────────────────────────────────────────────┘
```

**结论：用 AES-GCM，一步到位解决加密+完整性。**

## 最小例子

### Python 示例（使用 cryptography 库）

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

# 1. 生成密钥（32字节 = 256位）
key = AESGCM.generate_key(bit_length=256)  # 实际应用中要安全存储！

# 2. 创建加密器
aesgcm = AESGCM(key)

# 3. 生成随机IV（nonce），每次加密必须不同！
nonce = os.urandom(12)  # 12字节是GCM推荐长度

# 4. 加密
plaintext = b"Hello, Cryptography!"
ciphertext = aesgcm.encrypt(nonce, plaintext, None)

print(f"明文: {plaintext}")
print(f"密文: {ciphertext.hex()}")
print(f"密文长度: {len(ciphertext)} 字节")  # 比明文多16字节（认证标签）

# 5. 解密
decrypted = aesgcm.decrypt(nonce, ciphertext, None)
print(f"解密: {decrypted}")
```

### 输出示例
```
明文: b'Hello, Cryptography!'
密文: 7a9f3e2c1b...（每次运行都不同）
密文长度: 36 字节
解密: b'Hello, Cryptography!'
```

### 命令行示例（OpenSSL）

```bash
# 加密文件
openssl enc -aes-256-gcm -in secret.txt -out secret.enc -k "mypassword"

# 解密文件
openssl enc -d -aes-256-gcm -in secret.enc -out secret_decrypted.txt -k "mypassword"
```

## 新手最常踩的 3 个坑

### 坑1：使用 ECB 模式

```
❌ 错误示范
cipher = AES.new(key, AES.MODE_ECB)

✅ 正确做法
cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
```

**为什么是坑：** ECB模式下，相同的明文块会产生相同的密文块。著名的"ECB企鹅"就是例子——加密后的图片仍然能看出企鹅轮廓！

### 坑2：IV/Nonce 重复使用

```
❌ 错误示范
nonce = b'fixed_nonce!'  # 写死的nonce
for message in messages:
    encrypt(key, nonce, message)  # 灾难！

✅ 正确做法
for message in messages:
    nonce = os.urandom(12)  # 每次都生成新的！
    ciphertext = encrypt(key, nonce, message)
    save(nonce + ciphertext)  # nonce要和密文一起保存
```

**为什么是坑：** 在GCM模式下，nonce重复会直接泄露密钥！这不是"安全性降低"，是"完全破解"。

### 坑3：用密码直接当密钥

```
❌ 错误示范
password = "123456"
key = password.encode()  # 密码直接当密钥

✅ 正确做法
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

# 用密钥派生函数（KDF）把密码转成密钥
kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000)
key = kdf.derive(password.encode())
```

**为什么是坑：**
- 用户密码熵值低，容易被字典攻击
- 密码长度不固定，直接用会报错
- 没有salt，相同密码会得到相同密钥

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     安全通信流程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  身份验证 → 密钥交换 → ████████████████                         │
│                       │ 对称加密通信 │  ← 你在这里！             │
│                       ████████████████                         │
│                                                                 │
│  对称加密是最后一步：双方已经有了共享密钥，                        │
│  用这个密钥加密实际传输的数据。                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**上游依赖：** 密钥交换（需要先有共享密钥）
**下游消费：** 加密后的数据传输

## 自测题

### 题目1：为什么HTTPS不只用非对称加密？

<details>
<summary>点击查看答案</summary>

因为非对称加密太慢了（比对称加密慢约1000倍），不适合加密大量数据。所以HTTPS用非对称加密来"交换密钥"，然后用对称加密来"加密实际数据"。这叫混合加密。

</details>

### 题目2：下面的代码有什么问题？

```python
key = b'mysecretkey12345'  # 16字节
cipher = AES.new(key, AES.MODE_CBC, iv=b'0000000000000000')
```

<details>
<summary>点击查看答案</summary>

两个问题：
1. **IV是固定的**：应该每次加密都使用随机IV
2. **IV是全零**：即使不考虑随机性，全零IV也是特别糟糕的选择

正确做法：`iv = os.urandom(16)`

</details>

### 题目3：对称加密能保证消息没被篡改吗？

<details>
<summary>点击查看答案</summary>

取决于模式：
- **普通模式（ECB/CBC）**：不能！攻击者可以篡改密文，解密后得到被篡改的明文
- **认证加密模式（GCM/CCM）**：能！这些模式会附带认证标签，篡改后解密会失败

所以推荐使用GCM模式，一步到位。

</details>

---

## 总结

| 要点 | 内容 |
|------|------|
| 核心概念 | 同一个密钥加密和解密 |
| 推荐算法 | AES-256-GCM |
| 关键原则 | 密钥要安全存储，Nonce不能重复 |
| 最大局限 | 密钥分发问题——第一次怎么安全交换密钥？ |

**下一步：** 学习[非对称加密](02-asymmetric-encryption.md)，看它如何解决密钥分发问题！
