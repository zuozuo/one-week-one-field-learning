# 哈希函数（Hash Function）

## 一句话大白话

**哈希函数就是给任意数据生成一个固定长度的"指纹"。就像人的指纹——每个人不同，而且只能用来识别，不能反推出这个人长什么样。**

```
任意长度的数据 → [哈希函数] → 固定长度的哈希值

"Hello"        → SHA-256 → 2cf24dba5fb0a30e...（64位十六进制）
整本《红楼梦》  → SHA-256 → 也是64位十六进制
```

## 它解决什么问题

哈希函数解决的是**完整性验证**和**快速比对**问题。

**使用场景：**

| 场景 | 怎么用 |
|------|--------|
| 文件下载验证 | 对比下载文件的哈希和官方公布的哈希，确认没被篡改 |
| 密码存储 | 存密码的哈希，不存明文密码 |
| 数字签名 | 签名前先对消息做哈希，再签哈希值 |
| 数据去重 | 比较哈希值比比较原始数据快得多 |
| 区块链 | 每个区块包含前一个区块的哈希，形成链条 |
| Git版本控制 | 每个commit用内容哈希作为ID |

**生活类比：**
你有1000本书，想找重复的。一本一本对比内容太慢了。但如果给每本书计算一个"指纹"（哈希），只要比对指纹就行——快多了！

## 哈希函数的三大特性

### 1. 单向性（不可逆）

```
正向：Hello → 2cf24dba5fb0a30e...  ✅ 容易
逆向：2cf24dba5fb0a30e... → ???    ❌ 不可能

这不是解密，根本没有"密钥"这个概念！
```

### 2. 确定性

```
同样的输入 → 永远产生同样的输出

Hash("Hello") 今天算是 abc123...
Hash("Hello") 明天算还是 abc123...
Hash("Hello") 在火星上算还是 abc123...
```

### 3. 雪崩效应

```
Hash("Hello")  → 2cf24dba5fb0a30e26e83b2ac5b9e29e...
Hash("Hello!") → 33da2dd4b895...（完全不同！）

只改一个字符，结果天差地别。
这意味着你不能通过结果猜测输入的相似性。
```

### 4. 抗碰撞性

```
很难找到两个不同的输入，产生相同的输出。

Hash(A) = Hash(B)  但 A ≠ B  → 这叫"碰撞"
好的哈希函数让碰撞几乎不可能发生。
```

## 什么时候用 / 什么时候别用

### ✅ 适合用的场景

| 场景 | 说明 |
|------|------|
| 验证数据完整性 | 比对文件是否被修改 |
| 密码存储 | 配合盐值存储密码哈希 |
| 唯一标识 | 用内容生成ID（如Git commit） |
| 快速查找 | HashMap/HashTable |
| 数字签名前处理 | 先哈希再签名 |

### ❌ 不适合用的场景

| 场景 | 原因 |
|------|------|
| 加密数据 | 哈希不是加密！不可逆意味着数据丢失 |
| 不加盐存密码 | 会被彩虹表攻击 |
| 需要保密的场景 | 相同输入总产生相同输出 |

## 它不是什么（常见混淆）

| 误解 | 真相 |
|------|------|
| "哈希是加密" | ❌ 加密可以解密，哈希不能"解哈希" |
| "MD5可以用来加密" | ❌ MD5是哈希，而且已经不安全 |
| "哈希值是唯一的" | ⚠️ 理论上会碰撞，但好的算法碰撞概率极低 |
| "哈希长度代表安全性" | ⚠️ 有关系但不绝对，MD5有128位但已被破解 |

## 主要算法对比

| 算法 | 输出长度 | 状态 | 说明 |
|------|----------|------|------|
| MD5 | 128位 | ❌ 已淘汰 | 已被碰撞攻击破解，别用了 |
| SHA-1 | 160位 | ❌ 已淘汰 | 2017年被实际碰撞，Chrome等已不信任 |
| **SHA-256** | 256位 | ✅ 推荐 | 目前主流，比特币用的就是这个 |
| SHA-384 | 384位 | ✅ 可用 | 更长的变体 |
| SHA-512 | 512位 | ✅ 可用 | 64位系统上可能更快 |
| SHA-3 | 可变 | ✅ 可用 | 最新标准，备选方案 |
| BLAKE2 | 可变 | ✅ 可用 | 快，现代应用使用 |
| **bcrypt/scrypt/Argon2** | 可变 | ✅ 密码专用 | 专门设计来慢！ |

**选择建议：**
- 通用场景用 **SHA-256**
- 存密码用 **bcrypt** 或 **Argon2**
- 需要速度用 **BLAKE2**

## 最小例子

### Python 示例：基本哈希

```python
import hashlib

# SHA-256 哈希
message = b"Hello, World!"
hash_obj = hashlib.sha256(message)
hash_hex = hash_obj.hexdigest()

print(f"原文: {message}")
print(f"SHA-256: {hash_hex}")
print(f"长度: {len(hash_hex)} 个十六进制字符 = {len(hash_hex) * 4} 位")

# 输出：
# 原文: b'Hello, World!'
# SHA-256: dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f
# 长度: 64 个十六进制字符 = 256 位
```

### Python 示例：雪崩效应演示

```python
import hashlib

def show_hash(text):
    h = hashlib.sha256(text.encode()).hexdigest()
    print(f"'{text}' → {h[:16]}...")

show_hash("Hello")
show_hash("Hello!")
show_hash("Hello?")
show_hash("hello")  # 只是大小写不同

# 输出：
# 'Hello' → 185f8db32271fe25...
# 'Hello!' → 33b6dacf47c37a1f...  完全不同！
# 'Hello?' → 5c1b72e7b7b71e0e...  又完全不同！
# 'hello' → 2cf24dba5fb0a30e...  大小写不同，结果也不同
```

### Python 示例：文件哈希（验证下载）

```python
import hashlib

def file_hash(filepath):
    sha256 = hashlib.sha256()
    with open(filepath, 'rb') as f:
        while chunk := f.read(8192):
            sha256.update(chunk)
    return sha256.hexdigest()

# 验证下载的文件
downloaded_hash = file_hash("ubuntu-22.04.iso")
official_hash = "a4acfda10b18da50e..."  # 官网公布的

if downloaded_hash == official_hash:
    print("文件完整 ✅")
else:
    print("文件被篡改或损坏 ❌")
```

### Python 示例：正确存储密码

```python
import bcrypt

# 注册时：存储密码哈希
password = b"user_password_123"
salt = bcrypt.gensalt(rounds=12)  # 12轮，约0.3秒
hashed = bcrypt.hashpw(password, salt)

print(f"存入数据库: {hashed}")
# $2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.V...

# 登录时：验证密码
input_password = b"user_password_123"
if bcrypt.checkpw(input_password, hashed):
    print("密码正确 ✅")
else:
    print("密码错误 ❌")
```

### 命令行示例

```bash
# 计算文件的SHA-256
sha256sum myfile.txt

# 计算字符串的SHA-256
echo -n "Hello" | sha256sum

# macOS上用shasum
shasum -a 256 myfile.txt
```

## 新手最常踩的 3 个坑

### 坑1：直接存储密码的哈希（不加盐）

```
❌ 错误示范
password_hash = sha256(password)  # 彩虹表一查就出来

✅ 正确做法
# 使用专门的密码哈希函数（自带盐值）
hashed = bcrypt.hashpw(password, bcrypt.gensalt())
```

**为什么是坑：**
- 攻击者有预计算的"彩虹表"
- 常见密码的哈希值都已被记录
- 没有盐值，相同密码产生相同哈希，批量破解很容易

### 坑2：用MD5或SHA-1存密码

```
❌ 错误示范
password_hash = hashlib.md5(password).hexdigest()

✅ 正确做法
# 用bcrypt/scrypt/Argon2，它们设计成慢的！
hashed = bcrypt.hashpw(password, bcrypt.gensalt(rounds=12))
```

**为什么是坑：**
- MD5/SHA已被破解碰撞
- 它们太快了！GPU一秒能算几十亿次
- bcrypt/Argon2故意设计得慢，让暴力破解不可行

### 坑3：以为哈希能"解密"

```
❌ 错误想法
original = decrypt(hash_value)  # 不存在这个操作！

✅ 正确理解
# 哈希是单向的，只能比对，不能还原
if hash(input) == stored_hash:
    print("匹配！")
```

**为什么是坑：** 从数学上不可能从哈希值还原原文。所谓"破解MD5"是指找碰撞或用彩虹表查，不是解密。

## 密码存储的正确方式

```
┌─────────────────────────────────────────────────────────────────┐
│                    密码存储最佳实践                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  用户注册：                                                      │
│                                                                 │
│  密码 "abc123"                                                  │
│       │                                                         │
│       ▼                                                         │
│  生成随机盐 salt = "x7f9..."                                    │
│       │                                                         │
│       ▼                                                         │
│  哈希 = slow_hash(密码 + salt, cost=12)                        │
│       │                                                         │
│       ▼                                                         │
│  存储：[hash, salt, algorithm, cost]                           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  用户登录：                                                      │
│                                                                 │
│  输入密码 → 取出存储的salt → 同样方式哈希 → 比对结果            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

为什么要慢？
- SHA-256: 1秒算10亿次 → 暴力破解很快
- bcrypt(cost=12): 1秒算几次 → 暴力破解要几百年
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     安全通信流程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  身份验证 → 密钥交换 → 加密通信                                  │
│      ↑                    ↑                                     │
│      │                    │                                     │
│  数字签名             完整性校验                                 │
│      ↑                    │                                     │
│      │                    │                                     │
│  ████████████ ← ─ ─ ─ ─ ─┘                                     │
│  │ 哈希函数 │  ← 你在这里！                                     │
│  ████████████                                                   │
│      │                                                          │
│      ▼                                                          │
│  • 签名前先对消息做哈希                                          │
│  • 验证数据完整性                                                │
│  • 密码存储                                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**上游依赖：** 无（基础组件）
**下游消费：** 数字签名、完整性校验、HMAC

## 哈希 vs 加密 对比表

| 特性 | 哈希 | 加密 |
|------|------|------|
| 可逆性 | ❌ 不可逆 | ✅ 可解密 |
| 需要密钥 | ❌ 不需要 | ✅ 需要 |
| 输出长度 | 固定 | 取决于输入 |
| 用途 | 验证、指纹 | 保密 |
| 相同输入 | 相同输出 | 可能不同(有IV时) |

## 自测题

### 题目1：你下载了一个软件，官方公布SHA-256是abc123...，你算出来是def456...，说明什么？

<details>
<summary>点击查看答案</summary>

说明文件被篡改或下载不完整。

可能的原因：
1. 下载过程中文件损坏
2. 被中间人篡改（植入病毒）
3. 你下载的不是官方版本

处理方式：删除文件，从官方渠道重新下载。

</details>

### 题目2：为什么存储密码要用bcrypt而不是SHA-256？

<details>
<summary>点击查看答案</summary>

因为SHA-256太快了！

- SHA-256：GPU一秒能算几十亿次
- bcrypt：设计成慢，一秒只能算几次

攻击者暴力破解时：
- 用SHA-256：10位密码可能几小时破解
- 用bcrypt：同样密码需要几百年

bcrypt还内置了盐值，自动防彩虹表。

</details>

### 题目3：两个文件的MD5相同，能说明它们内容一定相同吗？

<details>
<summary>点击查看答案</summary>

不能！

MD5已被证明存在碰撞：可以构造两个不同的文件，却有相同的MD5值。

2004年，研究人员就演示了MD5碰撞。2012年，Flame恶意软件利用MD5碰撞伪造了Windows更新签名。

这就是为什么现在要用SHA-256而不是MD5。

但SHA-256目前还没发现碰撞，相同SHA-256几乎可以确定内容相同（概率上）。

</details>

---

## 总结

| 要点 | 内容 |
|------|------|
| 核心概念 | 任意数据→固定长度指纹，单向不可逆 |
| 推荐算法 | 通用SHA-256，密码存储用bcrypt/Argon2 |
| 关键特性 | 单向、确定、雪崩、抗碰撞 |
| 最大误区 | 哈希不是加密！存密码不加盐是灾难！ |

**下一步：** 学习[数字签名](04-digital-signature.md)，看哈希如何与非对称加密结合！
