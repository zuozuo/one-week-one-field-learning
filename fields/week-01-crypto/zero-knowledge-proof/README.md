# 零知识证明 (Zero-Knowledge Proof) 学习框架

## 1. 终极目标

### 解决的问题
**如何在不泄露任何秘密信息的情况下，向别人证明你确实知道这个秘密？**

想象这个场景：你知道一个保险箱的密码，你想向别人证明你确实知道密码，但又不想告诉他密码是什么。零知识证明就是解决这类问题的密码学技术。

### 最终交付物
- 理解零知识证明的三大核心性质
- 能够解释常见的 ZKP 协议（如 zk-SNARKs、zk-STARKs）
- 理解 ZKP 在区块链隐私保护中的应用
- 能够使用 ZKP 开发框架（如 circom、snarkjs）编写简单的零知识电路

### 评判标准
1. 能用大白话向非技术人员解释什么是零知识证明
2. 能独立阅读并理解 ZKP 相关的技术文档
3. 能编写并运行一个简单的零知识证明程序

### 验收任务
**独立使用 circom 编写一个"证明你知道某个数的平方根"的零知识电路，生成证明并验证，同时能解释为什么验证者无法从证明中获取原始数值。**

---

## 2. 流程全景图

### 零知识证明的完整流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        零知识证明系统全景图                                    │
└─────────────────────────────────────────────────────────────────────────────┘

                              【准备阶段】
    ┌──────────────────────────────────────────────────────────────┐
    │                                                              │
    │   问题定义 ──→ 电路设计 ──→ 可信设置 ──→ 生成密钥对           │
    │   (Statement)  (Circuit)   (Trusted    (Proving Key +        │
    │                             Setup)      Verification Key)    │
    └──────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                              【证明阶段】
    ┌──────────────────────────────────────────────────────────────┐
    │                                                              │
    │   证明者(Prover)                                              │
    │   ┌─────────┐    ┌─────────┐    ┌─────────┐                 │
    │   │ 私密输入 │ +  │ 公开输入 │ +  │ 证明密钥 │                 │
    │   │(Witness)│    │(Public) │    │  (PK)   │                 │
    │   └────┬────┘    └────┬────┘    └────┬────┘                 │
    │        │              │              │                       │
    │        └──────────────┴──────────────┘                       │
    │                       │                                      │
    │                       ▼                                      │
    │              ┌────────────────┐                              │
    │              │   生成证明 π    │                              │
    │              │   (Proof)      │                              │
    │              └───────┬────────┘                              │
    └──────────────────────┼───────────────────────────────────────┘
                           │
                           ▼
                      【验证阶段】
    ┌──────────────────────────────────────────────────────────────┐
    │                                                              │
    │   验证者(Verifier)                                            │
    │   ┌─────────┐    ┌─────────┐    ┌─────────┐                 │
    │   │  证明 π  │ +  │ 公开输入 │ +  │ 验证密钥 │                 │
    │   │ (Proof) │    │(Public) │    │  (VK)   │                 │
    │   └────┬────┘    └────┬────┘    └────┬────┘                 │
    │        │              │              │                       │
    │        └──────────────┴──────────────┘                       │
    │                       │                                      │
    │                       ▼                                      │
    │              ┌────────────────┐                              │
    │              │   验证结果      │                              │
    │              │ Accept/Reject  │                              │
    │              └────────────────┘                              │
    └──────────────────────────────────────────────────────────────┘
```

### 各阶段详细说明

```
┌─────────────┬──────────────────┬────────────────────┬──────────────────────┐
│    阶段     │      输入         │       加工         │        输出          │
├─────────────┼──────────────────┼────────────────────┼──────────────────────┤
│ 1.问题定义  │ 业务需求          │ 形式化为数学命题    │ Statement(陈述)      │
│             │                  │                    │ "我知道x使得f(x)=y"  │
├─────────────┼──────────────────┼────────────────────┼──────────────────────┤
│ 2.电路设计  │ Statement        │ 转换为算术电路      │ Circuit(电路)        │
│             │                  │ (加法门、乘法门)    │                      │
├─────────────┼──────────────────┼────────────────────┼──────────────────────┤
│ 3.可信设置  │ Circuit          │ 生成公共参数        │ CRS(公共参考串)      │
│             │                  │ (需要安全仪式)      │ = (PK, VK)          │
├─────────────┼──────────────────┼────────────────────┼──────────────────────┤
│ 4.证明生成  │ Witness + PK     │ 运行证明算法        │ Proof π             │
│             │ + Public Input   │                    │ (简洁的证明)         │
├─────────────┼──────────────────┼────────────────────┼──────────────────────┤
│ 5.证明验证  │ Proof + VK       │ 运行验证算法        │ Accept / Reject     │
│             │ + Public Input   │                    │                      │
└─────────────┴──────────────────┴────────────────────┴──────────────────────┘
```

### 三大核心性质

```
                    零知识证明的三大支柱
                           │
          ┌────────────────┼────────────────┐
          │                │                │
          ▼                ▼                ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │ 完备性   │    │ 可靠性   │    │ 零知识性 │
    │Completeness│   │Soundness │    │Zero-Know.│
    └──────────┘    └──────────┘    └──────────┘
          │                │                │
          ▼                ▼                ▼
    如果陈述为真      如果陈述为假      验证者除了
    诚实的证明者      恶意证明者几乎    "陈述为真"
    总能说服验证者    不可能欺骗验证者  学不到任何东西
```

---

## 3. 核心概念导航

| 概念 | 一句话解释 | 详细教程 |
|------|-----------|----------|
| 零知识证明基础 | 在不泄露秘密的情况下证明你知道这个秘密 | [查看](tutorials/01-zkp-basics.md) |
| 交互式证明 | 证明者和验证者来回"对话"完成证明 | [查看](tutorials/02-interactive-proof.md) |
| 非交互式证明 | 一次性生成证明，无需来回交互 | [查看](tutorials/03-non-interactive-proof.md) |
| 算术电路 | 把计算问题转换成加法和乘法组成的电路 | [查看](tutorials/04-arithmetic-circuit.md) |
| R1CS约束系统 | 用数学等式描述电路的约束条件 | [查看](tutorials/05-r1cs.md) |
| zk-SNARKs | 简洁的非交互式零知识证明，证明很小很快 | [查看](tutorials/06-zk-snarks.md) |
| zk-STARKs | 不需要可信设置的零知识证明，抗量子攻击 | [查看](tutorials/07-zk-starks.md) |
| 可信设置 | 生成公共参数的安全仪式，需要"有毒废料"销毁 | [查看](tutorials/08-trusted-setup.md) |
| Witness(见证) | 证明者知道的秘密输入 | [查看](tutorials/09-witness.md) |
| circom实战 | 编写零知识电路的DSL语言 | [查看](tutorials/10-circom-practice.md) |

---

## 4. 实战案例

[查看单点穿透案例：证明你知道一个数的平方根](tutorials/case-study.md)

---

## 5. 学习路线图

```
Week 1: 概念理解
├── 理解零知识证明的动机和三大性质
├── 学习经典的"阿里巴巴洞穴"例子
└── 理解交互式 vs 非交互式证明

Week 2: 数学基础
├── 有限域和模运算
├── 椭圆曲线密码学基础
└── 多项式承诺

Week 3: 技术深入
├── 理解算术电路和 R1CS
├── 学习 Groth16 协议原理
└── 理解可信设置的意义

Week 4: 实战演练
├── 安装 circom 和 snarkjs
├── 编写第一个零知识电路
└── 完成验收任务
```

---

## 6. 学习自检清单

### 费曼检验
- [ ] 我能用"阿里巴巴洞穴"的例子向朋友解释什么是零知识证明吗？
- [ ] 我能解释为什么验证者无法从证明中获取任何额外信息吗？
- [ ] 我能说清楚 zk-SNARKs 和 zk-STARKs 的主要区别吗？

### 迁移检验
- [ ] 如果要证明"我知道两个数的乘积"，我能独立设计电路吗？
- [ ] 如果要在新项目中使用 ZKP，我知道如何选择合适的方案吗？
- [ ] 我能读懂 Zcash 或 zkSync 的技术文档吗？

### 深度检验
- [ ] 我能解释为什么需要"可信设置"？它的风险是什么？
- [ ] 我能说出 R1CS 约束是如何从电路生成的吗？
- [ ] 我理解为什么零知识证明是"计算完整性"的保证吗？

---

## 7. 推荐资源

### 入门读物
- [ZKP 科普：写给所有人的零知识证明](https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/1/zkp-back.md)
- [Vitalik 的 zk-SNARKs 系列博客](https://vitalik.ca/general/2021/01/26/snarks.html)

### 进阶教程
- [ZK Learning - Berkeley 课程](https://zk-learning.org/)
- [RareSkills ZK Book](https://www.rareskills.io/zk-book)

### 实战工具
- [circom 官方文档](https://docs.circom.io/)
- [snarkjs GitHub](https://github.com/iden3/snarkjs)
- [zkREPL - 在线 ZK 游乐场](https://zkrepl.dev/)

---

> **口诀：终局定方向，流程搭骨架，单点打通关，类比挂认知，闭环验真知。**
