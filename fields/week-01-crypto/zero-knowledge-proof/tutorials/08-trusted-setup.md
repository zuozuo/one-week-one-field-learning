# 可信设置 (Trusted Setup)

## 一句话大白话

**在开始使用 SNARK 之前，需要一群人一起"造一把锁"，造完之后每个人都要销毁自己的"钥匙碎片"，只要有一个人真的销毁了，这把锁就是安全的。**

就像银行金库的建造：需要多个工程师参与，每人知道一部分设计图，建完后全部销毁。只要有一个工程师是诚实的，金库就是安全的。

## 它解决什么问题

### 核心问题：如何生成公共参数？

SNARK 系统需要一套公共参数（CRS，Common Reference String）：
- **证明密钥（pk）**：证明者用来生成证明
- **验证密钥（vk）**：验证者用来验证证明

问题：这些参数怎么来的？

```
如果是一个人生成:
  那个人知道"后门"，可以伪造任何证明！

可信设置的解决方案:
  多个人一起生成，每人只知道一部分
  只要有一个人诚实销毁了自己的部分，就没人知道完整的"后门"
```

### 使用场景

1. **Groth16 等 SNARK 系统**：必须做可信设置
2. **隐私币（Zcash）**：著名的"Powers of Tau"仪式
3. **zkSync、Polygon zkEVM**：使用通用设置

## 什么时候用 / 什么时候别用

### 需要可信设置的系统

| 系统 | 设置类型 | 说明 |
|------|---------|------|
| Groth16 | 电路特定 | 每个电路都要做一次 |
| PLONK | 通用设置 | 做一次，所有电路共用 |
| Marlin | 通用设置 | 做一次，所有电路共用 |

### 不需要可信设置的系统

| 系统 | 原因 |
|------|------|
| STARKs | 透明设置，只用哈希函数 |
| Bulletproofs | 使用不同的数学结构 |
| Halo/Halo2 | 使用递归证明技巧绕过 |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "可信设置 = 后门" | 只有泄露才是后门，正常销毁就安全 |
| "只做一次就够了" | Groth16 每个电路都要做 |
| "参与者越多越安全" | 理论上一个诚实就够，但多人增加信心 |
| "可信设置很慢" | 现在有高效的分布式协议 |

## 最小例子：理解可信设置

### "有毒废料" τ（tau）

可信设置的核心是生成一个随机数 τ（tau）的"加密形式"：

```
需要生成:
  g^τ, g^τ², g^τ³, ..., g^τⁿ   (在群 G1 中)
  h^τ, h^τ², h^τ³, ..., h^τⁿ   (在群 G2 中)

其中 g, h 是椭圆曲线上的生成元

关键点:
  - 公开: g^τ, g^τ², ... (这些是 CRS)
  - 秘密: τ 本身 (这是"有毒废料"，必须销毁)
```

### 为什么 τ 泄露很危险？

```
如果攻击者知道 τ:
  1. 可以计算任意的 g^τⁱ
  2. 可以伪造 Groth16 证明
  3. 可以为任何虚假陈述生成"有效"证明

后果:
  整个系统的可靠性（Soundness）完全崩溃！
```

### MPC 协议：多方计算

```
设置参与者: Alice, Bob, Carol, ...

阶段 1: Alice 的贡献
  Alice 选择随机数 τ₁
  生成: g^τ₁, g^τ₁², g^τ₁³, ...
  销毁 τ₁
  把结果发给 Bob

阶段 2: Bob 的贡献
  Bob 选择随机数 τ₂
  计算: (g^τ₁)^τ₂ = g^(τ₁·τ₂), ...
  销毁 τ₂
  把结果发给 Carol

...继续...

最终结果:
  g^(τ₁·τ₂·τ₃·...) = g^τ

安全性:
  τ = τ₁ · τ₂ · τ₃ · ...
  只要有一个 τᵢ 被销毁，就没人知道 τ
```

### Python 演示

```python
import random
from typing import List, Tuple

# 模拟椭圆曲线群（简化为模运算）
P = 2**255 - 19  # 大素数
G = 9           # 生成元（简化）

def exp_mod(base: int, exp: int) -> int:
    """模幂运算"""
    return pow(base, exp, P)

def trusted_setup_single(g: int, n: int) -> Tuple[List[int], int]:
    """
    单人可信设置（不安全！）
    """
    tau = random.randint(1, P - 1)  # 秘密随机数

    # 生成 CRS: g^τ, g^τ², ..., g^τⁿ
    crs = []
    for i in range(n):
        crs.append(exp_mod(g, pow(tau, i + 1, P - 1)))

    return crs, tau  # 注意：真实情况下 tau 必须销毁！


def mpc_trusted_setup(g: int, n: int, num_participants: int) -> List[int]:
    """
    多方计算可信设置

    Args:
        g: 生成元
        n: CRS 长度
        num_participants: 参与者数量

    Returns:
        最终的 CRS
    """
    # 初始 CRS: g^1, g^2, ..., g^n (实际是 g^τ⁰的形式)
    crs = [exp_mod(g, i + 1) for i in range(n)]

    print(f"MPC 可信设置开始，{num_participants} 位参与者")
    print("=" * 50)

    combined_tau = 1  # 仅用于演示验证

    for i in range(num_participants):
        # 每个参与者选择随机数
        tau_i = random.randint(1, P - 1)
        combined_tau = (combined_tau * tau_i) % (P - 1)

        # 更新 CRS
        new_crs = []
        for j, c in enumerate(crs):
            # (g^τ)^τᵢ = g^(τ·τᵢ)
            new_c = exp_mod(c, pow(tau_i, j + 1, P - 1))
            new_crs.append(new_c)
        crs = new_crs

        print(f"参与者 {i + 1}: 贡献随机性并销毁 τ_{i + 1}")
        # 在真实场景中，tau_i 在这里被销毁

    print("=" * 50)
    print("设置完成！")

    # 验证（仅演示用）
    expected = exp_mod(g, combined_tau)
    actual = crs[0]
    print(f"验证: g^τ 计算正确? {expected == actual}")

    return crs


def demonstrate_attack(crs: List[int], g: int, tau: int):
    """
    演示知道 τ 的攻击者可以做什么
    """
    print("\n演示：如果攻击者知道 τ...")
    print("=" * 50)

    # 攻击者可以计算任意的 g^τⁱ
    print("攻击者可以计算任意 g^τⁱ:")
    for i in range(5):
        computed = exp_mod(g, pow(tau, i + 1, P - 1))
        from_crs = crs[i] if i < len(crs) else "超出范围"
        print(f"  g^τ^{i + 1} = {computed} (CRS中: {from_crs})")

    print("\n这意味着攻击者可以伪造任何证明！")


if __name__ == "__main__":
    # 单人设置（不安全）
    print("场景 1: 单人可信设置（不安全！）")
    print("=" * 50)
    crs_unsafe, tau = trusted_setup_single(G, 5)
    print(f"CRS: {crs_unsafe[:3]}...")
    print(f"τ (有毒废料): {tau}")
    demonstrate_attack(crs_unsafe, G, tau)

    print("\n" * 2)

    # 多方设置（安全）
    print("场景 2: MPC 可信设置（安全）")
    crs_safe = mpc_trusted_setup(G, 5, 3)
    print(f"CRS: {crs_safe[:3]}...")
    print("没有任何人知道最终的 τ！")
```

## 两种设置：电路特定 vs 通用

```
┌─────────────────────────────────────────────────────────────────┐
│                    可信设置类型对比                              │
├─────────────────────┬────────────────────┬─────────────────────┤
│                     │    电路特定设置    │      通用设置        │
│                     │  (Circuit-specific) │    (Universal)      │
├─────────────────────┼────────────────────┼─────────────────────┤
│   代表系统          │    Groth16         │    PLONK, Marlin    │
├─────────────────────┼────────────────────┼─────────────────────┤
│   电路更新          │   需要重新设置     │   不需要重新设置     │
├─────────────────────┼────────────────────┼─────────────────────┤
│   灵活性            │   低               │    高               │
├─────────────────────┼────────────────────┼─────────────────────┤
│   证明大小          │   最小             │    稍大             │
├─────────────────────┼────────────────────┼─────────────────────┤
│   适用场景          │   电路稳定的产品   │   需要迭代的产品     │
└─────────────────────┴────────────────────┴─────────────────────┘
```

## 著名的可信设置仪式

### Zcash Powers of Tau

```
时间: 2017-2018
参与者: 数百人
过程:
  1. 每个参与者获取前一个人的输出
  2. 加入自己的随机性
  3. 用各种方式销毁随机数（烧毁电脑、微波炉、物理销毁）
  4. 传递给下一个人

著名的销毁方式:
- 把电脑放进法拉第笼然后物理销毁
- 在切尔诺贝利核电站进行仪式
- 用微波炉烧毁硬件
- 在飞行中的飞机上进行然后销毁设备
```

### 永久 Powers of Tau

```
https://github.com/weijiekoh/perpetualpowersoftau

特点:
- 永久运行的仪式
- 任何人都可以参与
- 适用于通用设置（PLONK 等）
```

## 新手最常踩的 3 个坑

### 坑 1：以为"可信设置"意味着"不安全"

**错误理解**：有可信设置就不安全

**真相**：
```
可信设置的安全性:
  假设: N 个参与者中至少 1 个诚实
  结果: 没有人知道 τ，系统安全

实际情况:
  - Zcash 有数百个参与者
  - 只要其中一个人真的销毁了，就安全
  - 概率上几乎不可能所有人都是恶意的
```

### 坑 2：修改电路后忘记重新设置

**错误做法**：修改了 Groth16 电路，继续用旧的 pk/vk

**后果**：证明无效，验证失败，或者更糟——安全漏洞

**正确做法**：
- Groth16：每次电路修改都重新做设置
- 或者使用 PLONK 等通用设置方案

### 坑 3：低估"有毒废料"销毁的重要性

**错误做法**：只是"删除"文件

**正确做法**：
```
安全销毁方法:
1. 使用专门的安全删除工具（多次覆写）
2. 物理销毁存储介质
3. 在隔离环境中运行（air-gapped）
4. 使用一次性设备
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   电路编译 (circom)                                              │
│      │                                                          │
│      ↓                                                          │
│   R1CS                                                          │
│      │                                                          │
│      ↓                                                          │
│   ┌───────────┐                                                 │
│   │【你在这里】│ ← 在证明之前必须先完成                           │
│   │ 可信设置   │                                                 │
│   └───────────┘                                                 │
│      │                                                          │
│      ├──→ 证明密钥 (pk)                                         │
│      │                                                          │
│      └──→ 验证密钥 (vk)                                         │
│              │                                                  │
│              ↓                                                  │
│         证明生成 & 验证                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

可信设置是 SNARK 系统的**初始化步骤**。理解它的安全模型，才能正确评估整个系统的安全性。

## 自测题

1. **概念题**：解释为什么可信设置中的 τ 被称为"有毒废料"？如果泄露会发生什么？

2. **安全题**：假设有 100 个人参与可信设置，其中 99 个是恶意的（串通在一起），只有 1 个是诚实的。这个设置安全吗？为什么？

3. **设计题**：如果你要为一个新项目选择 ZKP 方案，你会选择 Groth16（电路特定设置）还是 PLONK（通用设置）？分别在什么情况下选择？

---

<details>
<summary>点击查看答案</summary>

1. **"有毒废料" τ 的危险性**：
   - τ 是生成 CRS 时使用的秘密随机数
   - 如果攻击者知道 τ，可以：
     - 计算任意的 g^τⁱ
     - 为任何陈述（包括虚假的）生成有效证明
     - 完全破坏系统的可靠性（Soundness）
   - 被称为"有毒废料"是因为：
     - 必须彻底销毁，像核废料一样危险
     - 一旦泄露就无法挽回
     - 可能导致灾难性后果

2. **99 恶意 vs 1 诚实的安全性**：
   - **是安全的！**
   - 原因：
     - 最终的 τ = τ₁ · τ₂ · ... · τ₁₀₀
     - 恶意方知道 τ₁...τ₉₉，但不知道 τ₁₀₀
     - 只要那 1 个诚实参与者真的销毁了自己的 τ₁₀₀
     - 没有人能计算出完整的 τ
   - 这就是 MPC 可信设置的魔力：1-of-N 诚实假设

3. **选择 Groth16 vs PLONK**：

   选择 **Groth16**：
   - 电路已经稳定，不会频繁修改
   - 需要最小的证明大小（链上验证 gas 敏感）
   - 需要最快的验证速度
   - 可以接受每次电路变更重新做设置

   选择 **PLONK**：
   - 电路还在开发迭代中
   - 不想每次修改都重新做可信设置
   - 有多个不同的电路需要支持
   - 证明大小稍大可以接受

</details>
