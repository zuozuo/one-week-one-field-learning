# 非交互式证明 (Non-Interactive Proof)

## 一句话大白话

**证明者一次性生成证明，发出去就完事了，不需要和验证者来回"聊天"。**

就像写一封信：你把所有要说的一次性写完，寄出去。收信人读完就能判断你说的对不对，不需要和你当面对质。

## 它解决什么问题

### 核心问题：交互式证明的局限性

交互式证明有几个痛点：
1. **双方必须同时在线**：验证者不在怎么办？
2. **无法广播证明**：每个验证者都要单独交互一次
3. **无法存储证明**：事后无法复查
4. **不适合区块链**：链上合约无法"对话"

### 使用场景

1. **区块链验证**：zk-Rollup、隐私币（Zcash）、跨链桥
2. **公开可验证**：任何人都能验证，不需要和证明者交互
3. **证明存档**：法律证据、审计记录
4. **批量验证**：一个证明，多方验证

## 什么时候用 / 什么时候别用

### 适合使用非交互式证明

| 场景 | 原因 |
|------|------|
| 区块链/智能合约 | 链上无法交互 |
| 一对多验证 | 一份证明多人验证 |
| 异步验证 | 验证者可以随时验证 |
| 需要证明存档 | 证明可以保存和复查 |

### 不适合使用非交互式证明

| 场景 | 原因 |
|------|------|
| 需要避免可信设置 | 某些 NIZK 需要可信设置 |
| 证明生成资源极度受限 | 非交互通常计算量更大 |
| 简单的身份验证 | 交互式可能更简单 |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "非交互 = 更安全" | 不对，安全性可以相当 |
| "非交互 = 更简单" | 不对，理论上更复杂 |
| "非交互不需要随机数" | 不对，只是随机数来源不同 |
| "非交互证明更小" | 不一定，取决于具体方案 |

## 最小例子：Fiat-Shamir 变换

### 核心思想

把交互式证明变成非交互式的魔法：**用哈希函数模拟验证者的随机挑战**。

```
交互式:                          非交互式 (Fiat-Shamir):
┌─────────┐                      ┌─────────┐
│ Peggy   │                      │ Peggy   │
│         │──── t ──→│           │         │
│         │          │ Victor    │         │──── (t, s) ──→│ Victor
│         │←── c ────│           │         │               │
│         │──── s ──→│           │ c = Hash(t, 公开输入)    │ c = Hash(t, 公开输入)
└─────────┘                      └─────────┘               │ 验证 s

挑战 c 由验证者生成              挑战 c 由哈希函数"生成"
```

### 为什么这样安全？

**关键假设：哈希函数是"随机预言机"（Random Oracle）**

- 哈希函数的输出看起来完全随机
- 证明者无法预测 Hash(t) 的值
- 所以 c = Hash(t) 就像是验证者随机选的一样

### 把 Schnorr 协议变成非交互式

```
交互式 Schnorr:                   非交互式 Schnorr:
1. Peggy: 发送 t = g^r            1. Peggy: 计算 t = g^r
2. Victor: 发送随机 c              2. Peggy: 计算 c = Hash(g, y, t)
3. Peggy: 发送 s = r + c·x        3. Peggy: 计算 s = r + c·x
4. Victor: 验证 g^s = t·y^c       4. Peggy: 发送证明 π = (t, s)
                                  5. Victor: 计算 c = Hash(g, y, t)
                                  6. Victor: 验证 g^s = t·y^c
```

### Python 实现

```python
import hashlib
from typing import Tuple

def hash_to_int(data: bytes, modulus: int) -> int:
    """将数据哈希为整数"""
    h = hashlib.sha256(data).hexdigest()
    return int(h, 16) % modulus

class NonInteractiveSchnorr:
    def __init__(self, p: int, g: int):
        self.p = p
        self.g = g

    def keygen(self) -> Tuple[int, int]:
        """生成密钥对"""
        import random
        x = random.randint(1, self.p - 2)
        y = pow(self.g, x, self.p)
        return x, y

    def prove(self, x: int, y: int, message: bytes = b"") -> Tuple[int, int]:
        """
        生成非交互式证明

        Args:
            x: 私钥
            y: 公钥
            message: 可选的消息（用于签名场景）

        Returns:
            (t, s): 证明
        """
        import random

        # 步骤 1: 选择随机数，计算承诺
        r = random.randint(1, self.p - 2)
        t = pow(self.g, r, self.p)

        # 步骤 2: 用 Fiat-Shamir 变换计算挑战
        # c = Hash(g || y || t || message)
        hash_input = f"{self.g}:{y}:{t}:{message.hex()}".encode()
        c = hash_to_int(hash_input, self.p - 1)

        # 步骤 3: 计算响应
        s = (r + c * x) % (self.p - 1)

        return t, s

    def verify(self, y: int, proof: Tuple[int, int], message: bytes = b"") -> bool:
        """
        验证非交互式证明

        Args:
            y: 公钥
            proof: (t, s) 证明
            message: 可选的消息

        Returns:
            是否验证通过
        """
        t, s = proof

        # 重新计算挑战（这是关键！）
        hash_input = f"{self.g}:{y}:{t}:{message.hex()}".encode()
        c = hash_to_int(hash_input, self.p - 1)

        # 验证: g^s = t · y^c
        left = pow(self.g, s, self.p)
        right = (t * pow(y, c, self.p)) % self.p

        return left == right


def demo():
    # 使用较大的素数（实际应用需要更大）
    p = 104729  # 素数
    g = 2       # 生成元

    protocol = NonInteractiveSchnorr(p, g)

    # 生成密钥
    x, y = protocol.keygen()
    print(f"私钥: x = {x}")
    print(f"公钥: y = {y}")

    # 生成证明（一次性，无需交互！）
    proof = protocol.prove(x, y)
    print(f"\n生成的证明: π = {proof}")

    # 验证证明（验证者独立完成，无需联系证明者！）
    result = protocol.verify(y, proof)
    print(f"验证结果: {'通过 ✓' if result else '失败 ✗'}")

    # 演示：带消息的签名
    message = b"Hello, Zero Knowledge!"
    proof_with_msg = protocol.prove(x, y, message)
    result_with_msg = protocol.verify(y, proof_with_msg, message)
    print(f"\n带消息的签名验证: {'通过 ✓' if result_with_msg else '失败 ✗'}")

    # 演示：篡改消息后验证失败
    result_tampered = protocol.verify(y, proof_with_msg, b"Tampered message")
    print(f"篡改消息后验证: {'通过 ✓' if result_tampered else '失败 ✗'}")


if __name__ == "__main__":
    demo()
```

### 输出示例

```
私钥: x = 42567
公钥: y = 89234

生成的证明: π = (12345, 67890)
验证结果: 通过 ✓

带消息的签名验证: 通过 ✓
篡改消息后验证: 失败 ✗
```

## Fiat-Shamir 的安全性

### 随机预言机模型

Fiat-Shamir 变换的安全性建立在 **随机预言机模型（ROM）** 上：

```
┌─────────────────────────────────────────────────────────────┐
│                    随机预言机假设                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   理想世界:                                                  │
│   ┌─────────┐      输入 x      ┌─────────────┐             │
│   │ 任何人  │ ───────────────→ │ 随机预言机   │             │
│   └─────────┘                  │ (真随机函数) │             │
│                   输出 y       └──────┬──────┘             │
│       ←───────────────────────────────┘                    │
│                                                             │
│   - 对于新的输入，输出完全随机                                │
│   - 对于相同的输入，输出相同                                  │
│   - 无法预测输出                                             │
│                                                             │
│   现实世界:                                                  │
│   用 SHA-256 等哈希函数近似随机预言机                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 为什么 Fiat-Shamir 是安全的？

**直觉解释**：

1. 在交互式协议中，安全性来自于验证者随机选择 c
2. 在 Fiat-Shamir 中，c = Hash(t, ...)
3. 因为哈希函数"像"随机函数，证明者无法预测 c
4. 证明者必须先"承诺" t，才能知道 c
5. 和交互式协议的安全性等价

**形式化**：如果原始交互式协议是安全的，且哈希函数是随机预言机，则 Fiat-Shamir 变换后的协议也是安全的。

## 新手最常踩的 3 个坑

### 坑 1：哈希输入不完整

**错误做法**：
```python
c = Hash(t)  # 只哈希承诺
```

**为什么危险**：攻击者可能在不同场景下重放证明

**正确做法**：
```python
c = Hash(g, y, t, message, context)  # 包含所有相关信息
```

### 坑 2：使用弱哈希函数

**错误做法**：使用 MD5 或 SHA-1

**为什么危险**：这些哈希函数已被攻破，无法安全地模拟随机预言机

**正确做法**：使用 SHA-256 或更强的哈希函数

### 坑 3：混淆"非交互"和"无需设置"

**错误理解**：非交互式证明不需要任何预设

**真相**：
- Fiat-Shamir 本身不需要可信设置
- 但很多 NIZK 方案（如 Groth16）需要可信设置来生成 CRS
- "非交互"和"是否需要可信设置"是两个独立的属性

```
                   需要可信设置？
                   ┌─────────────────────────────────┐
                   │    是        │       否         │
    ┌──────────────┼──────────────┼──────────────────┤
    │ 交互式       │    少见      │   Schnorr 等     │
    │──────────────┼──────────────┼──────────────────┤
    │ 非交互式     │   Groth16    │   STARKs,        │
    │              │   PLONK      │   Bulletproofs   │
    └──────────────┴──────────────┴──────────────────┘
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ZKP基础 → 交互式证明                                          │
│                 │                                               │
│                 ↓                                               │
│            ┌────────────┐                                       │
│            │【你在这里】 │                                       │
│            │ 非交互式证明 │                                       │
│            └────────────┘                                       │
│                 │                                               │
│      ┌──────────┴──────────┐                                   │
│      ↓                     ↓                                   │
│   需要可信设置           无需可信设置                            │
│   (SNARKs)              (STARKs)                               │
│      │                     │                                   │
│      ↓                     ↓                                   │
│   电路 → R1CS           电路 → AIR                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Fiat-Shamir 变换是连接交互式和非交互式的桥梁。理解它，就理解了为什么现代 ZKP 系统都是非交互式的。

## 自测题

1. **概念题**：解释 Fiat-Shamir 变换的核心思想。为什么用哈希函数可以替代验证者的随机挑战？

2. **安全题**：如果证明者在计算 c = Hash(t) 之前就知道 t 会是什么，这样安全吗？为什么？

3. **设计题**：假设你要设计一个"证明你知道某个文件的内容"的非交互式零知识证明系统，你会如何设计哈希输入？

---

<details>
<summary>点击查看答案</summary>

1. **核心思想**：用哈希函数的输出作为"虚拟验证者"的随机挑战。
   - 哈希函数是确定性的（相同输入 → 相同输出）
   - 但输出看起来是随机的（随机预言机假设）
   - 证明者必须先选择 t，才能计算 Hash(t)
   - 所以证明者无法"事先知道" c 来作弊

2. **不安全**。如果证明者事先知道 t，他可以：
   - 尝试不同的 t，找到一个使得 c = Hash(t) 对他有利的值
   - 或者针对已知的 c，反推出"合法"的 t
   - 这正是交互式协议中"先发送 t 再收到 c"的重要性

3. 设计建议：
   ```python
   c = Hash(
       protocol_version,      # 协议版本
       prover_public_key,     # 证明者公钥
       file_hash,             # 文件哈希（公开输入）
       commitment,            # 承诺值
       timestamp,             # 时间戳（可选）
       context                # 应用上下文
   )
   ```
   关键是包含所有能标识这次证明的唯一信息，防止重放攻击。

</details>
