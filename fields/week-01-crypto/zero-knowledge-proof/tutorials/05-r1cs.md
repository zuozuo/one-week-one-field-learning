# R1CS 约束系统 (Rank-1 Constraint System)

## 一句话大白话

**把算术电路转换成一堆"A × B = C"形式的数学等式，每个等式叫一个"约束"。**

就像做菜的配方：把复杂的菜谱拆成一步步的"加多少盐"、"炒多少分钟"这样的简单步骤。R1CS 就是把复杂计算拆成最简单的"两个东西相乘等于第三个东西"的格式。

## 它解决什么问题

### 核心问题：如何统一表示各种计算？

算术电路已经把计算变成了门的组合，但不同的电路结构不一样。R1CS 提供了一个**标准化的表示格式**，让所有的证明系统都能处理。

```
任意计算 → 算术电路 → R1CS → 多项式 → 证明
                       ↑
                    【你在这里】
                    统一的中间格式
```

### 使用场景

1. **SNARK 证明系统的输入**：Groth16、PLONK 等都需要 R1CS
2. **zkVM**：把程序执行转换为 R1CS 约束
3. **电路编译器的输出**：circom 编译的产物就是 R1CS

## 什么时候用 / 什么时候别用

### R1CS 的优势

| 特点 | 说明 |
|------|------|
| 通用性强 | 任何计算都能表示 |
| 工具成熟 | circom、bellman 等支持 |
| 约束简单 | 每个约束形式统一 |

### R1CS 的局限

| 特点 | 说明 |
|------|------|
| 不够高效 | 某些运算需要很多约束 |
| 不支持查表 | 有些优化难以实现 |
| 被更新的格式替代 | PLONKish 算术化更灵活 |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "R1CS 是电路" | R1CS 是电路的另一种表示形式 |
| "只能有乘法" | 加法通过线性组合表达 |
| "约束越少越好" | 约束数量影响证明大小，但不是唯一因素 |

## 最小例子

### R1CS 的基本形式

每个 R1CS 约束长这样：

```
(a₀·w₀ + a₁·w₁ + ... + aₙ·wₙ) × (b₀·w₀ + b₁·w₁ + ... + bₙ·wₙ) = (c₀·w₀ + c₁·w₁ + ... + cₙ·wₙ)
          ↑                              ↑                              ↑
        左线性组合                      右线性组合                      输出线性组合
          (L)                           (R)                            (O)

简写: L × R = O

其中:
- w = (w₀, w₁, w₂, ..., wₙ) 是"见证向量"（所有变量的值）
- w₀ = 1（常数项）
- a, b, c 是系数（公开的）
```

### 例子 1：单个乘法门 x × y = z

```
变量: w = (1, x, y, z)
约束: x × y = z

用 R1CS 表示:
  L = (0, 1, 0, 0) · w = x
  R = (0, 0, 1, 0) · w = y
  O = (0, 0, 0, 1) · w = z

验证: L × R = x × y = z = O ✓
```

### 例子 2：加法 x + y = z

加法不直接是乘法，但可以通过技巧表示：

```
方法: 把 x + y = z 改写为 (x + y) × 1 = z

变量: w = (1, x, y, z)

  L = (0, 1, 1, 0) · w = x + y
  R = (1, 0, 0, 0) · w = 1
  O = (0, 0, 0, 1) · w = z

验证: L × R = (x + y) × 1 = z = O ✓
```

### 例子 3：完整计算 x³ + x + 5 = 35

```
原问题: 证明我知道 x 使得 x³ + x + 5 = 35
答案: x = 3

Step 1: 引入中间变量
  w = (1, x, v1, v2, out)
      1  x  v1=x²  v2=x³  out=35

Step 2: 列出乘法门
  约束1: x × x = v1        (计算 x²)
  约束2: v1 × x = v2       (计算 x³)
  约束3: (v2 + x + 5) × 1 = out  (最终输出)

Step 3: 转换为 R1CS 格式

  约束1: x × x = v1
    L = (0, 1, 0, 0, 0)    # 选中 x
    R = (0, 1, 0, 0, 0)    # 选中 x
    O = (0, 0, 1, 0, 0)    # 选中 v1

  约束2: v1 × x = v2
    L = (0, 0, 1, 0, 0)    # 选中 v1
    R = (0, 1, 0, 0, 0)    # 选中 x
    O = (0, 0, 0, 1, 0)    # 选中 v2

  约束3: (v2 + x + 5) × 1 = out
    L = (5, 1, 0, 1, 0)    # 5·1 + x + v2
    R = (1, 0, 0, 0, 0)    # 1
    O = (0, 0, 0, 0, 1)    # out
```

### Python 验证

```python
import numpy as np

def verify_r1cs(L, R, O, w):
    """
    验证 R1CS 约束: (L · w) × (R · w) = (O · w)

    Args:
        L, R, O: 约束矩阵（每行是一个约束）
        w: 见证向量
    """
    left = L @ w
    right = R @ w
    output = O @ w

    for i, (l, r, o) in enumerate(zip(left, right, output)):
        result = l * r
        print(f"约束{i+1}: {l} × {r} = {result}, 期望 {o}, {'✓' if result == o else '✗'}")

    return all(left * right == output)


# 例子: x³ + x + 5 = 35, x = 3

# 见证向量: (1, x, v1=x², v2=x³, out)
w = np.array([1, 3, 9, 27, 35])

# 约束矩阵
L = np.array([
    [0, 1, 0, 0, 0],  # 约束1: 选中 x
    [0, 0, 1, 0, 0],  # 约束2: 选中 v1
    [5, 1, 0, 1, 0],  # 约束3: 5 + x + v2
])

R = np.array([
    [0, 1, 0, 0, 0],  # 约束1: 选中 x
    [0, 1, 0, 0, 0],  # 约束2: 选中 x
    [1, 0, 0, 0, 0],  # 约束3: 选中 1
])

O = np.array([
    [0, 0, 1, 0, 0],  # 约束1: 选中 v1
    [0, 0, 0, 1, 0],  # 约束2: 选中 v2
    [0, 0, 0, 0, 1],  # 约束3: 选中 out
])

print("验证 R1CS 约束:")
result = verify_r1cs(L, R, O, w)
print(f"\n总体结果: {'全部通过 ✓' if result else '验证失败 ✗'}")
```

输出：
```
验证 R1CS 约束:
约束1: 3 × 3 = 9, 期望 9, ✓
约束2: 9 × 3 = 27, 期望 27, ✓
约束3: 35 × 1 = 35, 期望 35, ✓

总体结果: 全部通过 ✓
```

## R1CS 的矩阵形式

### 完整的 R1CS 定义

```
给定:
- 见证向量 w = (1, x₁, x₂, ..., xₙ)
- 三个矩阵 A, B, C，每个大小为 m × (n+1)
  其中 m = 约束数量，n = 变量数量

R1CS 满足条件:
  (A · w) ⊙ (B · w) = (C · w)

其中 ⊙ 表示逐元素乘法（Hadamard 积）
```

### 可视化

```
     A · w              B · w              C · w
  ┌─────────┐        ┌─────────┐        ┌─────────┐
  │ L₁ · w  │        │ R₁ · w  │        │ O₁ · w  │
  │ L₂ · w  │   ⊙    │ R₂ · w  │   =    │ O₂ · w  │
  │   ...   │        │   ...   │        │   ...   │
  │ Lₘ · w  │        │ Rₘ · w  │        │ Oₘ · w  │
  └─────────┘        └─────────┘        └─────────┘

每一行是一个约束: Lᵢ × Rᵢ = Oᵢ
```

## 从电路到 R1CS 的转换规则

### 规则 1：乘法门

```
电路: a × b = c

R1CS:
  L = 选中 a
  R = 选中 b
  O = 选中 c
```

### 规则 2：加法（用乘以 1）

```
电路: a + b = c

R1CS:
  L = 选中 (a + b)
  R = 选中 1
  O = 选中 c
```

### 规则 3：常数乘法

```
电路: 5 × a = c

R1CS:
  L = 5 倍的 a
  R = 选中 1
  O = 选中 c
```

### 规则 4：复杂表达式（拆分）

```
电路: (a + b) × (c + d) = e

拆分:
  t1 = a + b
  t2 = c + d
  t1 × t2 = e

R1CS:
  约束1: (a + b) × 1 = t1
  约束2: (c + d) × 1 = t2
  约束3: t1 × t2 = e
```

## 新手最常踩的 3 个坑

### 坑 1：忘记常数项 w₀ = 1

**错误**：见证向量只包含变量

```python
# 错误
w = [x, y, z]

# 正确
w = [1, x, y, z]  # 第一个元素必须是 1
```

**原因**：常数项需要通过 w₀ = 1 来表示。比如约束 "x + 5 = y"：
- L = (5, 1, 0)，则 L · w = 5·1 + 1·x + 0·y = 5 + x

### 坑 2：约束数量估计错误

**错误预期**："n 个乘法应该有 n 个约束"

**真相**：加法、常数处理、中间变量都可能增加约束

```
例子: x² + y² = z

分解:
  t1 = x × x    # 约束1
  t2 = y × y    # 约束2
  t1 + t2 = z   # 约束3（加法也是约束！）

共 3 个约束，不是 2 个
```

### 坑 3：混淆公开输入和私密输入

在 R1CS 中，见证向量 w 包含所有值，但有些是**公开的**，有些是**私密的**：

```
w = (1, public_inputs..., private_inputs...)

Groth16 等系统会把公开输入单独处理，验证者需要知道公开输入的值。
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   算术电路                                                       │
│      │                                                          │
│      ↓                                                          │
│   ┌───────────┐                                                 │
│   │【你在这里】│ ← 把电路转成 (L × R = O) 的约束格式              │
│   │   R1CS    │                                                 │
│   └───────────┘                                                 │
│      │                                                          │
│      ↓                                                          │
│   QAP (多项式表示)                                               │
│      │                                                          │
│      ↓                                                          │
│   Groth16 / PLONK 等证明系统                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

R1CS 是**电路到多项式的桥梁**。理解 R1CS，就理解了 SNARK 系统的输入是什么样子。

## 高级话题预览：从 R1CS 到 QAP

R1CS 之后，还需要转换为 QAP（Quadratic Arithmetic Program）才能用于 SNARK：

```
R1CS: (A · w) ⊙ (B · w) = (C · w)
         │
         ↓ 多项式插值
         │
QAP:  A(x) · B(x) - C(x) = H(x) · Z(x)

其中:
- A(x), B(x), C(x) 是多项式
- Z(x) 是"消失多项式"
- H(x) 是商多项式
```

这个转换让验证者可以用**一次多项式计算**来检验所有约束！

## 自测题

1. **基础题**：写出 "a × b + c = d" 的 R1CS 约束（需要引入中间变量）

2. **分析题**：以下 R1CS 约束检验的是什么计算？
   ```
   w = (1, a, b, c)
   L = (0, 1, 1, 0)
   R = (0, 1, -1, 0)
   O = (0, 0, 0, 1)
   ```

3. **计算题**：如果 w = (1, 5, 3, ?) ，上题中 c 应该等于多少才能满足约束？

---

<details>
<summary>点击查看答案</summary>

1. "a × b + c = d" 的 R1CS：
   ```
   w = (1, a, b, c, d, t)  # t = a×b

   约束1: a × b = t
     L = (0, 1, 0, 0, 0, 0)
     R = (0, 0, 1, 0, 0, 0)
     O = (0, 0, 0, 0, 0, 1)

   约束2: (t + c) × 1 = d
     L = (0, 0, 0, 1, 0, 1)  # c + t
     R = (1, 0, 0, 0, 0, 0)  # 1
     O = (0, 0, 0, 0, 1, 0)  # d
   ```

2. 约束检验的计算：
   ```
   L · w = a + b
   R · w = a - b
   O · w = c

   所以: (a + b) × (a - b) = c
   即:   a² - b² = c
   ```
   这是在验证差平方公式！

3. c 的值：
   ```
   a = 5, b = 3
   c = a² - b² = 25 - 9 = 16
   ```
   所以 w = (1, 5, 3, 16)

</details>
