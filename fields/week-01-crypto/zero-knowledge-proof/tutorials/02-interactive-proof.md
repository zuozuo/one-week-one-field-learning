# 交互式证明 (Interactive Proof)

## 一句话大白话

**证明者和验证者像打乒乓球一样，你来我往地"对话"，最终验证者被说服。**

就像法庭上的质询：律师（验证者）不断提问，证人（证明者）不断回答。通过多轮问答，律师判断证人说的是不是真话。

## 它解决什么问题

### 核心问题：如何验证复杂的陈述？

有些问题很难直接验证，但可以通过"提问-回答"的方式来检验。

**例子**：你声称记住了整本《哈利波特》
- 直接验证：让你背一遍（太慢了！）
- 交互式验证：我随机问你"第 127 页第 3 行是什么"，连问 100 次

如果你真记住了，每次都能答对。如果你没记住，总会露馅。

### 使用场景

1. **计算验证**：验证某个复杂计算的结果是否正确
2. **知识证明**：证明你知道某个秘密
3. **身份验证**：证明你是某个身份的持有者
4. **博弈论应用**：在不信任的双方之间建立信任

## 什么时候用 / 什么时候别用

### 适合使用交互式证明

| 场景 | 原因 |
|------|------|
| 验证者在线且可交互 | 交互需要双方都在 |
| 安全性要求高 | 多轮交互更难伪造 |
| 简单协议设计 | 交互式协议通常更直观 |
| 研究和学习 | 概念更清晰 |

### 不适合使用交互式证明

| 场景 | 原因 |
|------|------|
| 验证者离线 | 无法完成交互 |
| 一对多验证 | 每个验证者都要单独交互一次 |
| 区块链场景 | 链上无法交互，需要非交互式 |
| 需要长期存储证明 | 交互式证明无法"保存" |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "交互越多越安全" | 不对，关键是随机性和轮数的设计 |
| "交互式 = 低效" | 不对，很多情况下交互式反而更高效 |
| "必须人工交互" | 不对，计算机可以自动完成交互 |
| "交互式不能有零知识性" | 不对，交互式 ZKP 也有零知识性 |

### 交互式证明 vs 非交互式证明

```
┌──────────────────┬─────────────────────┬─────────────────────┐
│      特性        │     交互式证明      │    非交互式证明      │
├──────────────────┼─────────────────────┼─────────────────────┤
│   通信模式       │   多轮往返          │   单向发送          │
│   验证者状态     │   需要在线          │   可离线            │
│   证明可转移性   │   不可转移          │   可转移            │
│   设置要求       │   无需预设          │   通常需要 CRS      │
│   适用场景       │   在线身份验证      │   区块链、公开验证   │
└──────────────────┴─────────────────────┴─────────────────────┘
```

## 最小例子：Schnorr 身份识别协议

这是一个经典的交互式零知识证明协议，用于证明"我知道离散对数"。

### 背景知识

在一个素数 p 的群中：
- 公开参数：素数 p，生成元 g，公钥 y = g^x mod p
- 私密知识：私钥 x（离散对数）

Peggy 想证明她知道 x，但不想泄露 x。

### 协议流程

```
    Peggy (证明者)                    Victor (验证者)
    知道: x (私钥)                    知道: y = g^x (公钥)

    ┌─────────────────────────────────────────────────────┐
    │ 第 1 步：承诺 (Commitment)                          │
    │                                                     │
    │ 选择随机数 r                                        │
    │ 计算 t = g^r mod p                                  │
    │                            ─────── t ──────→        │
    └─────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────┐
    │ 第 2 步：挑战 (Challenge)                           │
    │                                                     │
    │                            ←────── c ───────        │
    │                                   (随机数)          │
    └─────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────┐
    │ 第 3 步：响应 (Response)                            │
    │                                                     │
    │ 计算 s = r + c·x mod (p-1)                          │
    │                            ─────── s ──────→        │
    └─────────────────────────────────────────────────────┘

    ┌─────────────────────────────────────────────────────┐
    │ 第 4 步：验证 (Verification)                        │
    │                                                     │
    │                     验证: g^s = t · y^c mod p       │
    │                     如果相等，则接受                 │
    └─────────────────────────────────────────────────────┘
```

### 为什么这是正确的？

```
验证等式: g^s = t · y^c mod p

左边 = g^s
     = g^(r + c·x)
     = g^r · g^(c·x)
     = g^r · (g^x)^c
     = t · y^c  ← 右边 ✓
```

### 三大性质分析

| 性质 | 如何满足 |
|------|---------|
| **完备性** | 知道 x 的 Peggy 总能计算出正确的 s |
| **可靠性** | 不知道 x 就无法在不知道 c 之前算出正确的 t |
| **零知识** | Victor 看到的 (t, c, s) 可以被模拟器伪造 |

### Python 实现

```python
import random
from typing import Tuple

def mod_exp(base: int, exp: int, mod: int) -> int:
    """模幂运算"""
    return pow(base, exp, mod)

class SchnorrProtocol:
    def __init__(self, p: int, g: int):
        """
        初始化 Schnorr 协议

        Args:
            p: 大素数
            g: 生成元
        """
        self.p = p
        self.g = g

    def keygen(self) -> Tuple[int, int]:
        """生成密钥对"""
        x = random.randint(1, self.p - 2)  # 私钥
        y = mod_exp(self.g, x, self.p)      # 公钥
        return x, y

    def prove_step1(self) -> Tuple[int, int]:
        """证明者：第一步，生成承诺"""
        r = random.randint(1, self.p - 2)
        t = mod_exp(self.g, r, self.p)
        return r, t

    def challenge(self) -> int:
        """验证者：生成随机挑战"""
        return random.randint(1, self.p - 2)

    def prove_step2(self, r: int, c: int, x: int) -> int:
        """证明者：第二步，生成响应"""
        s = (r + c * x) % (self.p - 1)
        return s

    def verify(self, t: int, c: int, s: int, y: int) -> bool:
        """验证者：验证证明"""
        left = mod_exp(self.g, s, self.p)
        right = (t * mod_exp(y, c, self.p)) % self.p
        return left == right


def run_protocol():
    """运行一次完整的协议"""
    # 使用小素数演示（实际应用需要大素数）
    p = 23  # 素数
    g = 5   # 生成元

    protocol = SchnorrProtocol(p, g)

    # 生成密钥
    x, y = protocol.keygen()
    print(f"私钥 x = {x}")
    print(f"公钥 y = g^x = {y}")

    # 协议执行
    r, t = protocol.prove_step1()
    print(f"\n步骤1 - 承诺: t = g^r = {t}")

    c = protocol.challenge()
    print(f"步骤2 - 挑战: c = {c}")

    s = protocol.prove_step2(r, c, x)
    print(f"步骤3 - 响应: s = r + c*x = {s}")

    result = protocol.verify(t, c, s, y)
    print(f"\n验证结果: {'通过 ✓' if result else '失败 ✗'}")

    return result


# 运行示例
if __name__ == "__main__":
    # 正常情况：证明者知道私钥
    print("=== 诚实的证明者 ===")
    run_protocol()

    print("\n" + "="*50 + "\n")

    # 作弊情况：证明者不知道私钥
    print("=== 作弊的证明者（随机猜测）===")
    p, g = 23, 5
    protocol = SchnorrProtocol(p, g)
    _, y = protocol.keygen()

    # 作弊者随机生成 t
    fake_t = random.randint(1, p-1)
    c = protocol.challenge()
    fake_s = random.randint(1, p-2)

    result = protocol.verify(fake_t, c, fake_s, y)
    print(f"验证结果: {'通过 ✓' if result else '失败 ✗'}")
```

## 新手最常踩的 3 个坑

### 坑 1：在发送承诺前泄露随机数

**错误做法**：先告诉验证者 r，再发送 t

**为什么危险**：如果验证者先知道 r，他可以选择特定的 c 来攻击

**正确做法**：必须先发送承诺 t（锁定 r），然后才能接收挑战 c

### 坑 2：重复使用随机数

**错误做法**：每次证明使用同一个 r

**为什么危险**：
```
第一次: s1 = r + c1·x
第二次: s2 = r + c2·x
相减得: s1 - s2 = (c1 - c2)·x
求解得: x = (s1 - s2) / (c1 - c2)  ← 私钥泄露！
```

**正确做法**：每次证明都生成新的随机数 r

### 坑 3：以为交互式证明可以"录像"转给别人

**错误理解**：我把和 Victor 的交互记录给 Alice 看，Alice 也能相信

**为什么不行**：Alice 会怀疑你和 Victor 串通好了。交互式证明的安全性依赖于验证者亲自生成随机挑战。

**解决方案**：使用非交互式证明（下一章）

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ZKP基础                                                       │
│      │                                                          │
│      ↓                                                          │
│   ┌───────────┐                                                 │
│   │【你在这里】│                                                 │
│   │ 交互式证明 │ ──→ 理解"对话"式的证明机制                       │
│   └───────────┘                                                 │
│      │                                                          │
│      ↓                                                          │
│   非交互式证明（Fiat-Shamir 变换）                               │
│      │                                                          │
│      ↓                                                          │
│   电路设计 → R1CS → SNARKs/STARKs                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

交互式证明是理解零知识证明的基础。非交互式证明本质上是用密码学技巧"模拟"了交互过程。

## 自测题

1. **概念题**：Schnorr 协议中，为什么 Peggy 必须先发送承诺 t，然后才能收到挑战 c？如果顺序反过来会怎样？

2. **计算题**：在 Schnorr 协议中，已知：
   - p = 23, g = 5
   - 公钥 y = 8
   - 证明者发送 t = 10, s = 7
   - 挑战 c = 3

   请验证这个证明是否有效。

3. **设计题**：如果你想证明"我知道两个数 a 和 b，使得 a + b = 10"，你会如何设计一个交互式零知识证明协议？

---

<details>
<summary>点击查看答案</summary>

1. 如果顺序反过来，证明者可以作弊：
   - 先收到 c
   - 随机选择 s
   - 计算 t = g^s / y^c（反推出一个"合法"的 t）
   - 这样不知道 x 也能通过验证

   先发送 t 是为了"锁定" r，防止这种作弊。

2. 验证过程：
   - 左边：g^s mod p = 5^7 mod 23 = 78125 mod 23 = 17
   - 右边：t · y^c mod p = 10 · 8^3 mod 23 = 10 · 512 mod 23 = 5120 mod 23 = 13
   - 17 ≠ 13，验证**失败**

3. 简单设计思路（Sigma 协议风格）：
   - 公开：目标和 S = 10
   - 私密：a, b 满足 a + b = 10
   - 承诺：选随机数 r1, r2，发送 C1 = Commit(a, r1), C2 = Commit(b, r2)
   - 挑战：验证者发送随机 c
   - 响应：证明者发送 (a+c, r1), (b-c, r2) 的某种组合
   - 验证：检查承诺和约束

   （这是简化版，实际需要更严谨的设计）

</details>
