# zk-SNARKs

## 一句话大白话

**证明很小、验证很快的零知识证明系统，但需要一个"可信设置"仪式。**

SNARKs 就像一张小纸条：不管你要证明的东西有多复杂，最后的证明都很短（几百字节），验证者瞄一眼就能确认。代价是开始之前需要一个特殊的"启动仪式"。

## 它解决什么问题

### 核心问题：证明太大、验证太慢

早期的零知识证明系统有两个痛点：
1. **证明大小**：与计算复杂度成正比，可能非常大
2. **验证时间**：验证者需要重新做一遍计算

**SNARK 的突破**：
- 证明大小：**常数**（约 200-300 字节）
- 验证时间：**常数**（几毫秒）

```
证明大小对比:
┌────────────────────┬─────────────────────┐
│     系统类型       │     证明大小        │
├────────────────────┼─────────────────────┤
│   普通证明         │   O(计算量)         │
│   STARKs          │   O(log²(计算量))   │
│   SNARKs          │   O(1) 约 200 字节  │
└────────────────────┴─────────────────────┘
```

### 使用场景

1. **区块链扩容（zk-Rollup）**：把大量交易压缩成一个小证明
2. **隐私币（Zcash）**：隐藏交易金额和地址
3. **链上验证**：gas 费用低（验证是常数时间）
4. **跨链桥**：证明另一条链上的状态

## SNARK 名字的含义

```
zk-SNARK = Zero-Knowledge Succinct Non-interactive ARgument of Knowledge

拆解:
- Zero-Knowledge:  零知识性
- Succinct:        简洁的（证明很小，验证很快）
- Non-interactive: 非交互式
- ARgument:        论证（计算上的安全性，非信息论安全）
- of Knowledge:    知识证明（证明者真的"知道"秘密）
```

## 什么时候用 / 什么时候别用

### 适合使用 SNARKs

| 场景 | 原因 |
|------|------|
| 链上验证 | 证明小、验证快、gas 低 |
| 大规模计算证明 | 证明大小与计算量无关 |
| 隐私交易 | 成熟的隐私保护方案 |
| 需要极致简洁 | 证明只有几百字节 |

### 不适合使用 SNARKs

| 场景 | 原因 |
|------|------|
| 不能接受可信设置 | 有安全假设和信任要求 |
| 需要抗量子 | 依赖椭圆曲线，量子不安全 |
| 电路频繁变化 | 每次变化都要重新做可信设置 |
| 证明生成资源极度受限 | 生成证明计算量大 |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "SNARK 不需要任何信任" | 需要可信设置（trusted setup） |
| "证明生成也很快" | 证明生成通常较慢，验证很快 |
| "SNARK 只有一种" | Groth16、PLONK、Marlin 等都是 SNARK |
| "SNARK 是量子安全的" | 基于椭圆曲线，量子计算机可以攻破 |

## 最小例子：理解 SNARK 的工作流程

### 完整流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         zk-SNARK 工作流程                               │
└─────────────────────────────────────────────────────────────────────────┘

【第一阶段：准备】（只做一次）

  电路设计 ──→ 编译为 R1CS ──→ 可信设置 ──→ (pk, vk)
                                  │
                                  ↓
                          "有毒废料"必须销毁
                          （否则可以伪造证明）

【第二阶段：证明】（每次都做）

  证明者:
  ┌──────────────────────────────────────────────────────────┐
  │                                                          │
  │   私密输入(witness) + 公开输入 + pk ──→ 证明 π          │
  │                                                          │
  │   时间复杂度: O(n·log n)，n = 约束数量                   │
  │                                                          │
  └──────────────────────────────────────────────────────────┘

【第三阶段：验证】（每次都做）

  验证者:
  ┌──────────────────────────────────────────────────────────┐
  │                                                          │
  │   证明 π + 公开输入 + vk ──→ Accept/Reject              │
  │                                                          │
  │   时间复杂度: O(1)，恒定时间！                           │
  │                                                          │
  └──────────────────────────────────────────────────────────┘
```

### 实际代码示例（snarkjs + circom）

```javascript
// 1. 定义电路 (circuit.circom)
pragma circom 2.0.0;

template Multiplier() {
    // 私密输入
    signal input a;
    signal input b;

    // 公开输出
    signal output c;

    // 约束: c = a * b
    c <== a * b;
}

component main = Multiplier();
```

```bash
# 2. 编译电路
circom circuit.circom --r1cs --wasm --sym

# 3. 可信设置（Powers of Tau 仪式）
# 3.1 开始仪式
snarkjs powersoftau new bn128 12 pot12_0000.ptau
# 3.2 贡献随机性
snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau
# 3.3 准备阶段2
snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau
# 3.4 生成电路特定的密钥
snarkjs groth16 setup circuit.r1cs pot12_final.ptau circuit_0000.zkey
# 3.5 再次贡献随机性
snarkjs zkey contribute circuit_0000.zkey circuit_final.zkey
# 3.6 导出验证密钥
snarkjs zkey export verificationkey circuit_final.zkey verification_key.json
```

```javascript
// 4. 生成证明
const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    { a: 3, b: 11 },           // 私密输入
    "circuit.wasm",            // 编译后的电路
    "circuit_final.zkey"       // 证明密钥
);

console.log("证明:", proof);
console.log("公开输出:", publicSignals);  // [33]  (因为 3 * 11 = 33)

// 5. 验证证明
const vKey = JSON.parse(fs.readFileSync("verification_key.json"));
const verified = await snarkjs.groth16.verify(vKey, publicSignals, proof);
console.log("验证结果:", verified);  // true
```

## 主流 SNARK 方案对比

```
┌──────────────┬────────────┬────────────┬────────────┬────────────────┐
│    方案      │  证明大小  │  验证时间  │ 可信设置   │     特点       │
├──────────────┼────────────┼────────────┼────────────┼────────────────┤
│   Groth16    │   ~200B    │  最快      │ 电路特定   │ 最简洁，最常用 │
│   PLONK      │   ~400B    │  快        │ 通用设置   │ 灵活，可更新   │
│   Marlin     │   ~1KB     │  较快      │ 通用设置   │ 学术上重要     │
│   Halo2      │   ~5KB     │  中等      │ 无需设置   │ 递归友好       │
└──────────────┴────────────┴────────────┴────────────┴────────────────┘

最常用: Groth16（追求极致简洁）和 PLONK（追求灵活性）
```

## Groth16 简介

Groth16 是最常用的 SNARK 方案，以发明者 Jens Groth 和发表年份 2016 命名。

### 核心特点

```
优点:
✓ 证明最小（约 200 字节，3 个群元素）
✓ 验证最快（3 次配对运算）
✓ 工具成熟（snarkjs、bellman 等）

缺点:
✗ 需要电路特定的可信设置
✗ 每次修改电路都要重新设置
✗ 可信设置的"有毒废料"必须销毁
```

### 证明结构

```
Groth16 证明 π = (A, B, C)

其中 A, B, C 是椭圆曲线上的点:
- A ∈ G1  (48 字节，BLS12-381)
- B ∈ G2  (96 字节，BLS12-381)
- C ∈ G1  (48 字节，BLS12-381)

总共: 约 192 字节
```

### 验证方程

```
验证者检查配对等式:
  e(A, B) = e(α, β) · e(公开输入项, γ) · e(C, δ)

其中:
- e() 是双线性配对函数
- α, β, γ, δ 是可信设置产生的参数
- 验证只需要 3 次配对运算（恒定时间）
```

## 新手最常踩的 3 个坑

### 坑 1：误以为 Groth16 的可信设置可以复用

**错误做法**：用同一套 (pk, vk) 验证不同的电路

**为什么错**：Groth16 的可信设置是**电路特定的**。换一个电路，必须重新做可信设置。

**解决方案**：
- 使用 PLONK 等"通用设置"方案
- 或者接受每次修改电路都重新设置

### 坑 2：低估证明生成时间

**错误预期**："验证那么快，生成应该也很快"

**真相**：
```
典型数据（100万约束）:
- 证明生成: 几十秒到几分钟
- 验证时间: 几毫秒

证明生成是 O(n·log n)，可能很慢！
```

**解决方案**：
- 使用 GPU 加速
- 优化电路设计，减少约束数量
- 使用 ZK 友好的原语（如 Poseidon 哈希）

### 坑 3：忽略可信设置的安全性

**危险**：如果可信设置的"有毒废料"泄露，任何人都能伪造证明！

```
"有毒废料" = 随机数 τ（tau）

知道 τ 的攻击者可以:
- 伪造任何陈述的证明
- 完全破坏系统的可靠性

这就是为什么需要"仪式"：多方参与，只要有一方诚实销毁了自己的随机数，系统就是安全的。
```

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   R1CS 约束系统                                                  │
│      │                                                          │
│      ├──────────────┬───────────────────┐                      │
│      ↓              ↓                   ↓                      │
│   ┌───────────┐  ┌────────┐        ┌────────┐                  │
│   │【你在这里】│  │ PLONK  │        │ STARKs │                  │
│   │  SNARKs   │  │        │        │        │                  │
│   │ (Groth16) │  └────────┘        └────────┘                  │
│   └───────────┘                                                 │
│      │                                                          │
│      ↓                                                          │
│   QAP + 椭圆曲线配对 → 简洁证明                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

SNARKs 是目前应用最广泛的 ZKP 技术，理解它是进入 ZK 应用开发的关键。

## 自测题

1. **概念题**：解释 SNARK 中 "Succinct" 的含义。为什么说证明大小是 O(1)？

2. **对比题**：Groth16 和 PLONK 在可信设置方面有什么区别？各有什么优缺点？

3. **安全题**：为什么 Groth16 的可信设置被称为"有毒废料"？如果泄露会发生什么？

---

<details>
<summary>点击查看答案</summary>

1. **Succinct 的含义**：
   - 证明大小与计算复杂度无关，始终是常数（约 200 字节）
   - 验证时间也是常数（几毫秒）
   - 不管你要证明的计算有多复杂（哪怕是执行一百万次操作），证明都一样小
   - 这是 SNARK 最重要的特性，使得链上验证成为可能

2. **Groth16 vs PLONK 的可信设置**：

   | | Groth16 | PLONK |
   |---|---|---|
   | 设置类型 | 电路特定 | 通用设置 |
   | 修改电路 | 需要重新设置 | 不需要 |
   | 设置大小 | 较小 | 较大 |
   | 证明大小 | 更小（~200B） | 稍大（~400B） |
   | 验证速度 | 更快 | 稍慢 |

   - Groth16：追求极致性能，适合电路稳定的场景
   - PLONK：追求灵活性，适合需要频繁迭代的场景

3. **"有毒废料"的危险**：
   - 可信设置过程中会产生秘密随机数 τ（tau）
   - 如果 τ 泄露，攻击者可以为任何（包括虚假的）陈述生成有效证明
   - 这会完全破坏系统的可靠性（Soundness）
   - 之所以叫"有毒废料"，是因为必须彻底销毁，就像核废料一样危险
   - 解决方案是 MPC 仪式：多方参与，只要一方诚实销毁，系统就安全

</details>
