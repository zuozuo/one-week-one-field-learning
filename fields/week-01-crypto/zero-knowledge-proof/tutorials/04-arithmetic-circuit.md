# 算术电路 (Arithmetic Circuit)

## 一句话大白话

**把任何计算都拆成只有"加法"和"乘法"的步骤，像搭积木一样组成一个电路图。**

就像小学数学：不管多复杂的题，最后都能用加减乘除算出来。算术电路就是把计算过程画成一张流程图，每个节点要么做加法，要么做乘法。

## 它解决什么问题

### 核心问题：如何把"任意计算"变成"可证明的"？

零知识证明需要一个统一的框架来描述各种计算问题：
- 证明我知道某个数的平方根
- 证明我知道一组交易满足某些规则
- 证明我执行了某段程序并得到某个结果

**算术电路 = 计算的"乐高化"**

### 为什么是加法和乘法？

```
┌─────────────────────────────────────────────────────────────┐
│   任何计算 ──→ 布尔电路(AND/OR/NOT) ──→ 算术电路(+/×)       │
└─────────────────────────────────────────────────────────────┘

原因：
1. 加法和乘法在数学上最好处理（多项式、有限域）
2. 可以用数学方程来描述约束
3. 便于构造零知识证明
```

### 使用场景

1. **零知识证明的基础层**：所有 SNARK/STARK 都需要先把问题转成电路
2. **可验证计算**：证明某段代码正确执行
3. **隐私计算**：在加密数据上做计算

## 什么时候用 / 什么时候别用

### 适合表达为算术电路

| 场景 | 原因 |
|------|------|
| 数学计算 | 天然就是加减乘除 |
| 哈希函数 | 可以用算术表达 |
| 签名验证 | 椭圆曲线运算本质是算术 |
| 比较运算 | 可以转换为算术约束 |

### 不太适合算术电路

| 场景 | 原因 |
|------|------|
| 循环次数不确定的程序 | 电路必须是固定结构 |
| 动态数据结构 | 电路大小必须预先确定 |
| 字符串处理 | 转换成本很高 |

## 它不是什么

### 常见混淆点

| 误解 | 真相 |
|------|------|
| "算术电路 = 电子电路" | 不对，这是数学抽象，不是物理电路 |
| "只能做简单计算" | 不对，图灵完备，理论上能计算任何东西 |
| "电路很小" | 不一定，复杂计算的电路可能非常大 |
| "加法乘法就够了" | 除法需要特殊处理（乘法逆元） |

### 算术电路 vs 布尔电路

```
┌─────────────────┬────────────────────┬────────────────────┐
│     特性        │     布尔电路       │     算术电路       │
├─────────────────┼────────────────────┼────────────────────┤
│   基本门        │   AND, OR, NOT     │   加法门, 乘法门    │
│   线上的值      │   0 或 1           │   有限域元素        │
│   适用场景      │   位运算           │   数值计算          │
│   ZKP中的使用   │   较少             │   主流              │
└─────────────────┴────────────────────┴────────────────────┘
```

## 最小例子

### 例子 1：证明 "我知道 x 使得 x² = 9"

```
输入:
  - 公开输入: y = 9
  - 私密输入: x = 3 (这是要证明知道的秘密)

电路:
          x
          │
          ↓
       ┌──────┐
       │  ×   │  ← 乘法门
       └──┬───┘
          │
          ↓
         x²
          │
          ↓
       ┌──────┐
       │  =   │  ← 约束：x² 必须等于 y
       └──────┘
          │
          ↓
          y (公开输入 = 9)
```

### 例子 2：证明 "我知道 a, b 使得 a × b + 5 = 20"

```
私密输入: a = 3, b = 5
公开输入: 常数 5, 结果 20

                a       b
                │       │
                └───┬───┘
                    │
                    ↓
                 ┌──────┐
                 │  ×   │ 乘法门
                 └──┬───┘
                    │
                    ↓
                   a×b (= 15)
                    │
                    │       5 (常数)
                    │       │
                    └───┬───┘
                        │
                        ↓
                     ┌──────┐
                     │  +   │ 加法门
                     └──┬───┘
                        │
                        ↓
                    a×b + 5 (= 20)
                        │
                        ↓
                     ┌──────┐
                     │  =   │ 约束
                     └──────┘
                        │
                        ↓
                       20 (公开输出)
```

### 例子 3：更复杂的计算 (x + y)² = x² + 2xy + y²

```
输入: x, y

                    x           y
                    │           │
         ┌──────────┼───────────┼──────────┐
         │          │           │          │
         ↓          │           │          ↓
      ┌──────┐      │           │       ┌──────┐
      │  ×   │      │           │       │  ×   │
      └──┬───┘      │           │       └──┬───┘
         │ (x²)     │           │          │ (y²)
         │          └─────┬─────┘          │
         │                │                │
         │                ↓                │
         │             ┌──────┐            │
         │             │  ×   │            │
         │             └──┬───┘            │
         │                │ (xy)           │
         │                ↓                │
         │             ┌──────┐            │
         │             │  ×2  │            │
         │             └──┬───┘            │
         │                │ (2xy)          │
         │                │                │
         └────────┬───────┼────────┬───────┘
                  │       │        │
                  ↓       ↓        ↓
               ┌─────────────────────┐
               │       +   +        │
               └──────────┬─────────┘
                          │
                          ↓
                    x² + 2xy + y²
```

## 有限域上的算术

### 为什么要用有限域？

在实际的 ZKP 系统中，所有计算都在 **有限域（Finite Field）** 上进行：

```
普通整数:    ..., -2, -1, 0, 1, 2, 3, ...     (无限个)
有限域 F_p:  0, 1, 2, ..., p-1                (p 个元素)

例如 F_7 = {0, 1, 2, 3, 4, 5, 6}

加法: (3 + 5) mod 7 = 1
乘法: (3 × 5) mod 7 = 15 mod 7 = 1
```

### 有限域的好处

1. **元素有限**：可以精确表示和计算
2. **有逆元**：每个非零元素都有乘法逆元，除法变成乘法
3. **与密码学兼容**：椭圆曲线、配对运算都在有限域上

### 代码示例

```python
class FiniteField:
    """简单的有限域实现"""

    def __init__(self, p: int):
        self.p = p  # 素数模数

    def add(self, a: int, b: int) -> int:
        return (a + b) % self.p

    def mul(self, a: int, b: int) -> int:
        return (a * b) % self.p

    def sub(self, a: int, b: int) -> int:
        return (a - b) % self.p

    def inv(self, a: int) -> int:
        """计算乘法逆元：a^(-1) mod p"""
        return pow(a, self.p - 2, self.p)

    def div(self, a: int, b: int) -> int:
        """除法 = 乘以逆元"""
        return self.mul(a, self.inv(b))


# 示例：F_7
field = FiniteField(7)

print(f"3 + 5 = {field.add(3, 5)}")  # 1
print(f"3 × 5 = {field.mul(3, 5)}")  # 1
print(f"3 - 5 = {field.sub(3, 5)}")  # 5 (因为 -2 mod 7 = 5)
print(f"3 / 5 = {field.div(3, 5)}")  # 2 (因为 5^(-1) mod 7 = 3, 3×3=9 mod 7=2)
```

## 电路的约束表示

### 从电路图到数学约束

每个门可以表示为一个数学等式：

```
加法门:  输出 = 输入1 + 输入2
         c = a + b

乘法门:  输出 = 输入1 × 输入2
         c = a × b
```

### 约束系统

把整个电路的所有约束列出来，就得到一个约束系统：

```
例子: 证明 x³ + x + 5 = 35 (答案是 x = 3)

电路分解:
  w1 = x × x      (计算 x²)
  w2 = w1 × x     (计算 x³)
  w3 = w2 + x     (计算 x³ + x)
  w4 = w3 + 5     (计算 x³ + x + 5)
  w4 = 35         (输出约束)

约束列表:
  1. w1 = x × x
  2. w2 = w1 × x
  3. w3 = w2 + x
  4. w4 = w3 + 5
  5. w4 = 35
```

## 实际应用：简单的 circom 风格伪代码

```javascript
// 证明我知道 secret 使得 hash(secret) = publicHash

template HashPreimage() {
    // 私密输入
    signal private input secret;

    // 公开输入
    signal input publicHash;

    // 中间变量
    signal hash;

    // 计算哈希（简化表示）
    hash <-- Hash(secret);

    // 约束：计算出的哈希必须等于公开哈希
    hash === publicHash;
}

// 实例化
component main = HashPreimage();
```

## 新手最常踩的 3 个坑

### 坑 1：忘记电路是静态的

**错误理解**：电路可以有 if-else 和动态循环

**真相**：电路结构必须在编译时确定！

```
// 错误：动态循环
for (i = 0; i < n; i++) {  // n 是运行时才知道的
    ...
}

// 正确：静态循环（编译时展开）
for (i = 0; i < 100; i++) {  // 100 是编译时常量
    ...
}

// 处理 if-else：两个分支都要算，用选择器选结果
result = selector * branch1 + (1 - selector) * branch2;
```

### 坑 2：混淆"赋值"和"约束"

```javascript
// 在 circom 中:
a <-- b;      // 赋值：计算 a 的值（不产生约束）
a === b;      // 约束：要求 a 必须等于 b
a <== b;      // 两者都做：赋值 + 约束
```

**危险**：只赋值不约束，可能导致证明者作弊！

### 坑 3：低估电路大小

**错误预期**："一个简单的哈希应该很小吧"

**真相**：SHA-256 在算术电路中需要约 30000 个约束！

```
常见操作的电路规模（约束数量级）:
- 加法/乘法:        1 个约束
- 比较 (a < b):     ~256 个约束（需要位分解）
- SHA-256:          ~30000 个约束
- 椭圆曲线点乘:     ~20000 个约束
- Poseidon 哈希:    ~300 个约束（ZK友好）
```

这就是为什么 ZKP 系统常用 "ZK 友好" 的哈希函数（如 Poseidon、Pedersen）。

## 流程图定位

```
┌─────────────────────────────────────────────────────────────────┐
│                     零知识证明系统全景图                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   问题定义: "证明我知道 x 使得 f(x) = y"                         │
│       │                                                         │
│       ↓                                                         │
│   ┌───────────┐                                                 │
│   │【你在这里】│                                                 │
│   │ 算术电路   │ ← 把计算表示为加法门和乘法门                     │
│   └───────────┘                                                 │
│       │                                                         │
│       ↓                                                         │
│   R1CS (Rank-1 Constraint System)                               │
│       │                                                         │
│       ↓                                                         │
│   多项式 (QAP/AIR)                                              │
│       │                                                         │
│       ↓                                                         │
│   证明系统 (SNARKs/STARKs)                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

算术电路是 ZKP 流程中**从问题到证明的第一步转换**。它把抽象的计算问题变成了具体的数学结构。

## 自测题

1. **基础题**：画出计算 "(a + b) × c" 的算术电路图。

2. **转换题**：如何用算术电路表达 "a ≠ 0" 这个约束？（提示：如果 a ≠ 0，则 a 有乘法逆元）

3. **思考题**：为什么 SHA-256 在算术电路中需要那么多约束，而 Poseidon 哈希只需要几百个约束？

---

<details>
<summary>点击查看答案</summary>

1. (a + b) × c 的电路图：
   ```
        a       b
        │       │
        └───┬───┘
            │
            ↓
         ┌──────┐
         │  +   │
         └──┬───┘
            │ (a+b)
            │       c
            └───┬───┘
                │
                ↓
             ┌──────┐
             │  ×   │
             └──┬───┘
                │
                ↓
            (a+b)×c
   ```

2. 表达 "a ≠ 0"：
   - 引入辅助变量 inv = a^(-1)（a 的乘法逆元）
   - 约束：a × inv = 1
   - 如果 a = 0，则不存在这样的 inv，约束无法满足
   - 这个技巧叫 "非零证明"

3. SHA-256 vs Poseidon：
   - SHA-256 设计用于 CPU 上的位运算（AND, XOR, SHIFT）
   - 这些位运算在算术电路中需要"位分解"：把数拆成 0/1 比特，每个比特是一个约束
   - Poseidon 专门为算术电路设计，只用加法和乘法
   - 类比：用乐高搭建筷子（Poseidon）vs 用乐高搭建电子琴（SHA-256）

</details>
