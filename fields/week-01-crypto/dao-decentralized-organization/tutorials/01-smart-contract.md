# 智能合约 (Smart Contract)

## 一句话大白话

**智能合约就是「自动售货机」**：你投币选饮料，机器自动出货——不需要店员，不能反悔，不能赖账。

---

## 它解决什么问题

### 核心痛点：信任成本太高

传统场景：
- 你和陌生人打赌「明天下雨我给你 100 块」
- 问题：谁来判定下没下雨？谁来强制执行？万一对方跑了呢？
- 传统方案：找公证人、写合同、打官司……成本极高

智能合约场景：
- 把「下雨判定标准」和「转账逻辑」写成代码
- 接入天气预报 API 作为数据源
- 到时间自动判定、自动转账
- **没有任何人能阻止或修改执行**

### 使用场景

1. **自动化支付**：工资按时发、租金按月扣
2. **条件触发**：达到某条件就自动执行某操作
3. **去信任协作**：不认识的人也能安全交易
4. **透明规则**：所有人都能看到规则，无法暗箱操作

---

## 什么时候用 / 什么时候别用

### 适合用智能合约

| 场景 | 原因 |
|------|------|
| 多方协作、互不信任 | 代码执行，无需信任 |
| 规则明确、可量化 | 代码擅长处理逻辑 |
| 需要透明、可审计 | 链上公开，不可篡改 |
| 涉及资金转移 | 自动执行，无法抵赖 |

### 不适合用智能合约

| 场景 | 原因 |
|------|------|
| 需要人为判断的情况 | 「这幅画美不美」代码判断不了 |
| 需要频繁修改规则 | 智能合约部署后很难改 |
| 隐私要求极高 | 链上数据公开可见 |
| 低价值交易 | gas 费可能比交易额还高 |

---

## 它不是什么

### 常见误解

| 误解 | 真相 |
|------|------|
| ❌ 智能合约很「智能」 | 其实是「自动执行的笨合约」，只会照章办事 |
| ❌ 智能合约是法律合同 | 是代码，不是法律文书（虽然有约束力） |
| ❌ 智能合约可以随便改 | 部署后基本不能改（除非有升级机制） |
| ❌ 智能合约 100% 安全 | 代码有漏洞就会被黑（史上损失数十亿美元） |
| ❌ 智能合约能做所有事 | 只能操作链上数据，链下世界需要「预言机」 |

### 智能合约 vs 传统程序

```
传统程序                          智能合约
─────────────────────────────────────────────────────
运行在公司服务器上                 运行在全球节点上
公司可以随时修改                   部署后无法篡改
数据库可以删除                     链上记录永久保存
需要信任公司                       只需信任代码
免费或低成本                       每次操作要付 gas
```

---

## 最小例子

### 例子1：最简单的存钱罐合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimplePiggyBank {
    address public owner;

    constructor() {
        owner = msg.sender;  // 部署合约的人是主人
    }

    // 任何人可以存钱
    function deposit() public payable {
        // 钱自动进入合约地址
    }

    // 只有主人可以取钱
    function withdraw() public {
        require(msg.sender == owner, "Not owner!");
        payable(owner).transfer(address(this).balance);
    }

    // 查看余额
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
```

**这个合约做了什么？**
1. 任何人可以往里面存 ETH
2. 只有创建者（owner）可以取出所有 ETH
3. 余额公开可查

### 例子2：简单投票合约（DAO 的雏形）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleVoting {
    // 提案结构
    struct Proposal {
        string description;
        uint yesVotes;
        uint noVotes;
        bool executed;
    }

    Proposal[] public proposals;
    mapping(address => mapping(uint => bool)) public hasVoted;

    // 创建提案
    function createProposal(string memory _description) public {
        proposals.push(Proposal({
            description: _description,
            yesVotes: 0,
            noVotes: 0,
            executed: false
        }));
    }

    // 投票
    function vote(uint proposalId, bool support) public {
        require(!hasVoted[msg.sender][proposalId], "Already voted!");

        if (support) {
            proposals[proposalId].yesVotes++;
        } else {
            proposals[proposalId].noVotes++;
        }

        hasVoted[msg.sender][proposalId] = true;
    }

    // 查看结果
    function getResult(uint proposalId) public view returns (
        string memory description,
        uint yes,
        uint no
    ) {
        Proposal memory p = proposals[proposalId];
        return (p.description, p.yesVotes, p.noVotes);
    }
}
```

---

## 新手最常踩的 3 个坑

### 坑 1：以为部署后可以随便改

**错误想法**：「先上线，有 bug 再改」

**现实**：智能合约部署后，代码就固定了。想改只能：
- 部署新合约（旧数据丢失）
- 提前设计升级机制（复杂）
- 通过治理投票迁移（麻烦）

**教训**：部署前必须充分测试 + 审计

### 坑 2：忽视 gas 费

**错误想法**：「在本地测试没问题，上主网应该也行」

**现实**：
- 每一行代码都要花 gas
- 循环遍历大数组可能花费数百美元
- gas 价格波动剧烈

**教训**：
- 优化存储操作（最贵）
- 避免链上大循环
- 用 `view` 函数不花 gas（只读）

### 坑 3：不了解「预言机问题」

**错误想法**：「智能合约什么都能做」

**现实**：智能合约只能访问链上数据，无法直接获取：
- 天气、股价、比赛结果
- 其他网站的 API
- 现实世界的任何信息

**解决方案**：使用预言机（如 Chainlink）把链下数据「喂」给合约

```
真实世界 ──→ 预言机 ──→ 智能合约
(股价涨了)   (上报数据)   (触发清算)
```

---

## 流程图定位

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│  创建DAO  │───▶│ 获取投票权│───▶│ 发起提案  │───▶│ 社区投票  │───▶│ 执行决策  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
     ↑                                                              ↑
     │                                                              │
     └──── 智能合约是 DAO 的「操作系统」，贯穿整个流程 ────────────────┘

具体作用：
• 创建 DAO：部署治理合约、代币合约、国库合约
• 获取投票权：代币合约记录你的余额
• 发起提案：治理合约接收并存储提案
• 社区投票：治理合约记录每一票
• 执行决策：治理合约自动调用目标函数
```

---

## 自测题

### 基础题

1. **判断题**：智能合约部署后，创建者可以随时修改代码。（对/错）

2. **选择题**：以下哪个场景最适合用智能合约？
   - A. 判断一首歌好不好听
   - B. 自动按规则分配收益
   - C. 处理需要频繁变更的业务逻辑
   - D. 存储大量视频文件

3. **填空题**：智能合约无法直接获取链下数据，需要借助 _______ 来获取外部信息。

### 进阶题

4. **思考题**：为什么说智能合约「不需要信任」？如果代码有漏洞怎么办？

5. **实践题**：阅读上面的 `SimpleVoting` 合约，指出它有什么安全漏洞？（提示：谁都能投票吗？一个人能投多少票？）

---

## 答案

1. **错**。智能合约部署后代码不可修改，除非预先设计了升级机制。

2. **B**。自动按规则分配收益是智能合约的典型应用场景——规则明确、涉及资金、需要信任。

3. **预言机（Oracle）**

4. 「不需要信任」指的是不需要信任执行者（因为代码自动执行），但仍需要信任代码本身。如果代码有漏洞，资金可能被盗。所以部署前的审计非常重要。

5. `SimpleVoting` 的漏洞：
   - 任何地址都能投票（没有身份验证）
   - 每个地址只能投一票（但可以用多个地址）
   - 没有投票截止时间
   - 没有执行机制（投完票然后呢？）
   - 这就是为什么真实的 DAO 需要治理代币来限制投票权
